<!doctype html>
<html lang="my">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/default.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mermaid@11.12.0/dist/mermaid.min.css">
    <title>Golang</title>
    <style>
        :root {
            --page-margin: 1in;
            --text: #111;
            --muted: #666;
            --border: #ddd;
            --bg: #fff;
            --code-bg: #f6f8fa;
            --font: "PDA17-Burma Press", "Myanmar Sangam MN", "Noto Sans Myanmar", "Myanmar MN", "Myanmar Text", ui-serif, "Iowan Old Style", "Apple Garamond", "Palatino Linotype",
                Palatino, "Times New Roman", Times, serif;
            --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
                "Liberation Mono", "Courier New", monospace;
            --line-height: 2rem;
        }

        html {
            color: var(--text);
            background: var(--bg);
        }

        body {
            margin: 0;
            font: 11pt/1.5 var(--font);
            line-height: var(--line-height);
        }

        @page {
            margin: var(--page-margin);
        }

        @page :first {

            /* Hide page number on title page when supported. */
            @bottom-right {
                content: "";
            }
        }

        @page {

            /* CSS Paged Media margin boxes (supported by some PDF engines). */
            @bottom-right {
                content: counter(page);
                font: 10pt/1 var(--font);
                color: var(--muted);
            }
        }

        @media screen {
            body {
                padding: var(--page-margin);
            }
        }

        .title-page {
            break-after: page;
            page-break-after: always;
            text-align: center;
        }

        .title-page h1 {
            font: 38pt/1.1 var(--font);
            margin: 35vh 0 0;
        }

        .title-page .subtitle {
            margin-top: 10pt;
            color: var(--muted);
            font-size: 12pt;
        }

        .content h1 {
            break-before: page;
            page-break-before: always;
            margin: 0 0 12pt;
            padding-top: 12px;
        }

        .content h1:first-of-type {
            break-before: auto;
            page-break-before: auto;
        }

        h2,
        h3,
        h4 {
            break-after: avoid-page;
            page-break-after: avoid;
            margin: 18pt 0 8pt;
        }

        p,
        li {
            orphans: 3;
            widows: 3;
        }

        hr {
            border: none;
            border-top: 1px solid var(--border);
            margin: 14pt 0;
        }

        a {
            color: inherit;
            text-decoration: none;
        }

        pre,
        blockquote,
        table,
        img {
            break-inside: avoid;
            page-break-inside: avoid;
        }

        pre {
            background: var(--code-bg);
            border: 1px solid var(--border);
            border-radius: 6pt;
            padding: 10pt 12pt;
            margin: 10pt 0;
            font: 9.5pt/1.45 var(--mono);
            white-space: pre-wrap;
            overflow-wrap: anywhere;
        }

        code {
            font-family: var(--mono);
            font-size: 0.95em;
        }

        :not(pre)>code {
            background: rgba(0, 0, 0, 0.04);
            padding: 0.1em 0.25em;
            border-radius: 4pt;
        }

        blockquote {
            margin: 10pt 0;
            padding: 0 0 0 10pt;
            border-left: 3pt solid var(--border);
            color: #333;
        }

        ul,
        ol {
            padding-left: 1.2em;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 10pt 0;
        }

        th,
        td {
            border: 1px solid var(--border);
            padding: 6pt 8pt;
            vertical-align: top;
        }

        th {
            background: rgba(0, 0, 0, 0.03);
        }
    </style>
  </head>
  <body>
    <section class="title-page">
      <h1>Golang</h1>
      <div class="subtitle">By Gemini 3</div>
    </section>
    <article class="content">
      <h1 id="-go-">အခန်း ၁: Go ဘာသာစကား မိတ်ဆက်</h1>
<p>Go (Golang ဟုလည်း ခေါ်ကြသည်) သည် Google မှ Robert Griesemer, Rob Pike, နှင့် Ken Thompson တို့က ၂၀၀၇ ခုနှစ်တွင် စတင်ရေးဆွဲခဲ့ပြီး ၂၀၀၉ ခုနှစ်တွင် အများပြည်သူသို့ မိတ်ဆက်ခဲ့သော open-source programming language တစ်ခုဖြစ်သည်။ Go သည် ရိုးရှင်းမှု (simplicity), စွမ်းဆောင်ရည်မြင့်မားမှု (high performance), နှင့် concurrency (တစ်ပြိုင်နက်တည်း အလုပ်များစွာ လုပ်ဆောင်နိုင်မှု) တို့ကို အဓိကထား၍ ဒီဇိုင်းထုတ်ထားပါသည်။</p>
<h2 id="go-">Go ဆိုတာဘာလဲ။</h2>
<p>Go သည် statically typed, compiled programming language တစ်ခုဖြစ်ပြီး C++ သို့မဟုတ် Java ကဲ့သို့သော language များ၏ performance နှင့် C-like syntax ကို Python သို့မဟုတ် JavaScript ကဲ့သို့သော dynamic language များ၏ ရိုးရှင်းလွယ်ကူမှုနှင့် ပေါင်းစပ်ထားပါသည်။</p>
<p>၎င်း၏ အဓိကရည်ရွယ်ချက်မှာ ခေတ်မီ multi-core processor များ၊ computer network များနှင့် large codebases များအတွက် software များကို လွယ်ကူစွာ တည်ဆောက်နိုင်ရန် ဖြစ်သည်။</p>
<h2 id="-go-">ဘာကြောင့် Go ကို ရွေးချယ်သင့်သလဲ။</h2>
<p>Go ကို software developer များစွာက နှစ်သက်စွာ အသုံးပြုလာကြရခြင်း၏ အဓိကအကြောင်းအရင်းများမှာ-</p>
<ul>
<li><p><strong>Performance:</strong> Go သည် compiled language ဖြစ်သောကြောင့် machine code သို့ တိုက်ရိုက် compile လုပ်သည်။ ထို့ကြောင့် interpreted languages များဖြစ်သော Python သို့မဟုတ် Ruby တို့ထက် များစွာပိုမိုမြန်ဆန်ပါသည်။</p>
</li>
<li><p><strong>Concurrency:</strong> Go ၏ အစွမ်းထက်ဆုံး feature မှာ concurrency ဖြစ်သည်။ Goroutines နှင့် Channels များကို အသုံးပြု၍ program များကို တစ်ပြိုင်နက်တည်း အလုပ်များစွာကို အလွန်လွယ်ကူစွာနှင့် ထိရောက်စွာ လုပ်ဆောင်နိုင်အောင် ရေးသားနိုင်ပါသည်။ ၎င်းသည် web servers, data pipelines နှင့် အခြားသော concurrent systems များ တည်ဆောက်ရာတွင် အလွန်အသုံးဝင်ပါသည်။</p>
</li>
<li><p><strong>Simplicity:</strong> Go ၏ syntax သည် ရိုးရှင်းပြီး သင်ယူရန် လွယ်ကူသည်။ Language တွင် keywords အနည်းငယ်သာ ပါရှိသောကြောင့် code များကို ဖတ်ရှုရန်နှင့် ပြုပြင်ထိန်းသိမ်းရန် (maintain) လွယ်ကူစေပါသည်။</p>
</li>
</ul>
<h2 id="go-">Go ၏ အားသာချက်များနှင့် အသုံးဝင်မှုများ</h2>
<h3 id="-">အားသာချက်များ</h3>
<ul>
<li><strong>Fast Compilation:</strong> Compile အလွန်မြန်ဆန်သောကြောင့် development process ကို ပိုမိုသွက်လက်စေသည်။</li>
<li><strong>Garbage Collection:</strong> Memory management ကို အလိုအလျောက် ပြုလုပ်ပေးသည်။</li>
<li><strong>Strong Standard Library:</strong> Web server, cryptography, I/O နှင့် အခြားသော လုပ်ဆောင်ချက်များစွာအတွက် built-in packages များ ပါဝင်သည်။</li>
<li><strong>Single Binary:</strong> Program ကို compile ပြုလုပ်ပြီးသောအခါ dependency များအားလုံးပါဝင်သော executable file တစ်ခုတည်းသာ ရရှိသောကြောင့် deployment ပြုလုပ်ရန် အလွန်လွယ်ကူသည်။</li>
</ul>
<h3 id="-">အသုံးဝင်မှုများ</h3>
<ul>
<li>Cloud &amp; Network Services</li>
<li>Command-line Interfaces (CLIs)</li>
<li>Web Development (Backend APIs)</li>
<li>DevOps &amp; Site Reliability Engineering (SRE)</li>
</ul>
<h2 id="go-company-">Go ကို အသုံးပြုနေသော နာမည်ကြီး Company များ</h2>
<p>Go ၏ စွမ်းဆောင်ရည်နှင့် ယုံကြည်စိတ်ချရမှုတို့ကြောင့် ကမ္ဘာ့ထိပ်တန်း နည်းပညာ company များစွာက ၎င်းတို့၏ systems များတွင် Go ကို ကျယ်ပြန့်စွာ အသုံးပြုနေကြပါသည်။ ဥပမာအချို့မှာ-</p>
<ul>
<li>Google (Go ကို ဖန်တီးခဲ့သည့် ကုမ္ပဏီ)</li>
<li>Uber</li>
<li>Twitch</li>
<li>Dropbox</li>
<li>SoundCloud</li>
<li>Netflix</li>
</ul>
<h1 id="-development-environment-">အခန်း ၂: Development Environment တည်ဆောက်ခြင်း</h1>
<p>Go programming language ဖြင့် software များ စတင်ရေးသားရန်အတွက် လိုအပ်သော development environment ကို မည်သို့တည်ဆောက်ရမည်ကို ဤအခန်းတွင် လေ့လာသွားပါမည်။ Go ကို install ပြုလုပ်ခြင်းမှစ၍ သင်၏ ပထမဆုံး &quot;Hello, World!&quot; program ကို ရေးသား run ကြည့်ခြင်းအထိ အဆင့်ဆင့် လမ်းညွှန်ပေးသွားပါမည်။</p>
<h2 id="go-install-windows-macos-linux-">Go ကို Install ပြုလုပ်ခြင်း (Windows, macOS, Linux)</h2>
<p>Go ကို စတင်အသုံးပြုရန်အတွက် သင်၏ ကွန်ပျူတာတွင် Go compiler နှင့် tools များကို install ပြုလုပ်ရန် လိုအပ်ပါသည်။</p>
<p>Go ၏ တရားဝင် website ဖြစ်သော <a href="https://go.dev/dl/">go.dev/dl/</a> တွင် သင်၏ operating system (Windows, macOS, Linux) အတွက် installer များကို အလွယ်တကူ download ရယူပြီး install ပြုလုပ်နိုင်ပါသည်။</p>
<p>Installation ပြီးစီးကြောင်း စစ်ဆေးရန် သင်၏ terminal သို့မဟုတ် command prompt တွင် အောက်ပါ command ကို ရိုက်ထည့်ကြည့်ပါ။</p>
<pre><code class="lang-sh">go version</code></pre>
<p><code>go version go1.xx.x</code> ကဲ့သို့သော စာကြောင်းကို မြင်ရပါက Go ကို အောင်မြင်စွာ install ပြုလုပ်ပြီးဖြစ်ပါသည်။</p>
<blockquote>
<p><strong>Note:</strong> အကယ်၍ <code>command not found</code> ဟုပြနေပါက သင်၏ terminal ကို ပိတ်ပြီး ပြန်ဖွင့်ပါ (restart)၊ သို့မဟုတ် log out လုပ်ပြီး log in ပြန်ဝင်ကြည့်ပါ။</p>
</blockquote>
<h2 id="workspace-gopath-">Workspace နှင့် GOPATH ကို နားလည်ခြင်း</h2>
<p>ယခင် Go version များတွင် <code>GOPATH</code> သည် Go projects များ၏ workspace ကို သတ်မှတ်ပေးသော environment variable တစ်ခုဖြစ်ပြီး အရေးပါခဲ့ပါသည်။ သို့သော် Go version 1.11 မှစ၍ <strong>Go Modules</strong> စနစ်ကို စတင်မိတ်ဆက်ခဲ့ပြီးနောက်ပိုင်းတွင် <code>GOPATH</code> ၏ အရေးပါမှုမှာ လျော့ကျသွားခဲ့သည်။</p>
<p>ယခုခေတ် Go development တွင် project များကို သင်၏ computer ရှိ မည်သည့် directory တွင်မဆို တည်ဆောက်နိုင်ပြီး <code>go mod</code> command ဖြင့် dependency များကို စီမံခန့်ခွဲနိုင်ပြီ ဖြစ်သောကြောင့် ပိုမိုလွယ်ကူလာပါသည်။ ဤစာအုပ်တွင်လည်း Go Modules ကို အခြေခံ၍ ဆက်လက်ရှင်းလင်းသွားပါမည်။</p>
<h2 id="code-editor-vs-code-setup-">Code Editor (VS Code) Setup ပြုလုပ်ခြင်း</h2>
<p>Go code များကို ရေးသားရန်အတွက် text editor အမျိုးမျိုးကို အသုံးပြုနိုင်သော်လည်း Visual Studio Code (VS Code) သည် Go developer များကြားတွင် ရေပန်းအစားဆုံး editor တစ်ခုဖြစ်သည်။</p>
<ol>
<li>VS Code ကို download လုပ်ပြီး install ပြုလုပ်ပါ။</li>
<li>VS Code ကိုဖွင့်ပြီး Extensions view (Ctrl+Shift+X) သို့ သွားပါ။</li>
<li>Search bar တွင် <code>Go</code> ဟု ရိုက်ရှာပြီး <strong>Go Team at Google</strong> မှ ထုတ်ဝေသော extension ကို install ပြုလုပ်ပါ။</li>
<li>၎င်း extension က code completion, debugging, testing နှင့် အခြားသော အသုံးဝင်သည့် feature များစွာကို ထောက်ပံ့ပေးပါလိမ့်မည်။</li>
<li>Extension ကို Install ပြုလုပ်ပြီးနောက်ညာဘက်အောက်ထောင့်တွင် Analysis Tools များ install လုပ်ရန် message box ပေါ်လာပါက <strong>Install All</strong> ကို နှိပ်၍ install လုပ်ပေးပါ။</li>
</ol>
<h2 id="-hello-world-">သင်၏ ပထမဆုံး ပရိုဂရမ်: &quot;Hello, World!&quot;</h2>
<p>သင်၏ ပထမဆုံး Go program ကို စတင်ရေးသားကြည့်ကြပါစို့။</p>
<ol>
<li><code>hello</code> အမည်ဖြင့် project folder အသစ်တစ်ခု တည်ဆောက်ပါ။</li>
<li>Terminal တွင် ထို folder ထဲသို့ <code>cd hello</code> ဖြင့် ဝင်ပါ။</li>
<li><code>go mod init example.com/hello</code> command ဖြင့် module အသစ်တစ်ခု ဖန်တီးပါ။</li>
<li><code>main.go</code> အမည်ဖြင့် file အသစ်တစ်ခုဖွင့်ပြီး အောက်ပါ code များကို ရေးသားပါ။</li>
</ol>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

func main() {
    fmt.Println(&quot;Hello, World!&quot;)
}</code></pre>
<ul>
<li><code>package main</code>: ဤ file သည် executable program တစ်ခုဖြစ်ကြောင်း ကြေညာသည်။</li>
<li><code>import &quot;fmt&quot;</code>: &quot;format&quot; package ကို import လုပ်ခြင်းဖြစ်သည်။ ၎င်း package တွင် <code>Println</code> ကဲ့သို့သော printing functions များ ပါဝင်သည်။</li>
<li><code>func main()</code>: Program စတင်ဆောင်ရွက်မည့် အဓိက function ဖြစ်သည်။</li>
<li><code>fmt.Println(...)</code>: Console တွင် စာသားများကို print ထုတ်ပေးသည်။</li>
</ul>
<h2 id="-go-run-go-build-go-install-commands-"><code>go run</code>, <code>go build</code>, <code>go install</code> Commands များ</h2>
<p>Terminal တွင် <code>main.go</code> file ရှိသော directory ထဲ၌ အောက်ပါ command များကို စမ်းသပ်ကြည့်နိုင်ပါသည်။</p>
<ul>
<li><p><strong><code>go run main.go</code></strong></p>
<ul>
<li>Code ကို compile လုပ်ပြီး တိုက်ရိုက် run ပေးသည်။ Executable file အသစ်ကို မဖန်တီးပါ။ Development ပြုလုပ်နေစဉ် program ကို အမြန်စမ်းသပ်ရန် အသုံးဝင်သည်။</li>
</ul>
</li>
<li><p><strong><code>go build</code></strong></p>
<ul>
<li>Code ကို compile လုပ်ပြီး လက်ရှိ directory ထဲတွင် <code>hello</code> (Windows တွင် <code>hello.exe</code>) အမည်ဖြင့် executable file တစ်ခု တည်ဆောက်ပေးသည်။ ထို file ကို အခြားနေရာများသို့ copy ယူပြီး တိုက်ရိုက် run နိုင်ပါသည်။</li>
</ul>
</li>
<li><p><strong><code>go install</code></strong></p>
<ul>
<li>Code ကို compile လုပ်ပြီး ရလာသော executable file ကို <code>$GOPATH/bin</code> (သို့မဟုတ် <code>GOBIN</code> သတ်မှတ်ထားလျှင် ထိုနေရာ) တွင် install ပြုလုပ်ပေးသည်။ ၎င်းသည် command-line tool များ ဖြန့်ဝေရန် အသုံးဝင်သည်။</li>
</ul>
</li>
</ul>
<h1 id="-go-syntax-">အခန်း ၃: Go ၏ အခြေခံ Syntax များ</h1>
<p>ယခုအခန်းတွင် Go programming language ၏ အခြေခံအကျဆုံးနှင့် အရေးအကြီးဆုံးဖြစ်သော syntax များကို လေ့လာသွားပါမည်။ Variables, constants, data types, operators နှင့် comments များ မည်သို့ရေးသားရမည်ကို ဥပမာများနှင့်တကွ ရှင်းလင်းဖော်ပြသွားပါမည်။</p>
<h2 id="variables-constants-">Variables နှင့် Constants များ ကြေညာခြင်း</h2>
<p>Go တွင် တန်ဖိုးများကို မှတ်သားသိမ်းဆည်းရန်အတွက် variables နှင့် constants များကို အသုံးပြုပါသည်။</p>
<h3 id="variables">Variables</h3>
<p>Variable ဆိုသည်မှာ program တစ်ခု run နေစဉ်အတွင်း တန်ဖိုးများ ပြောင်းလဲနိုင်သော memory location တစ်ခု၏ အမည်နာမ ဖြစ်သည်။ Go တွင် variable ကြေညာရန် နည်းလမ်းများစွာရှိသည်။</p>
<p><strong>1. <code>var</code> keyword ဖြင့် ကြေညာခြင်း</strong></p>
<p>Data type ကို တိတိကျကျ သတ်မှတ်ပေးနိုင်သည်။</p>
<pre><code class="lang-go">// data type ကို သတ်မှတ်ပြီး ကြေညာခြင်း
var name string = &quot;Aung Aung&quot;

// data type မပါဘဲ ကြေညာခြင်း (Go က တန်ဖိုးကိုကြည့်၍ type ကို အလိုအလျောက် သတ်မှတ်ပေးသည်)
var age = 25

// တန်ဖိုးမထည့်ဘဲ ကြေညာခြင်း (zero value ဖြစ်သည့် &quot;&quot; သို့မဟုတ် 0 ကို ရရှိမည်)
var address string</code></pre>
<p><strong>2. Short Variable Declaration (<code>:=</code>)</strong></p>
<p>ဤနည်းလမ်းသည် function များအတွင်းတွင် အသုံးအများဆုံးဖြစ်ပြီး <code>var</code> keyword နှင့် type ကို ရေးရန်မလိုဘဲ variable ကို အတို ကြေညာနိုင်သည်။</p>
<pre><code class="lang-go">func main() {
    // `:=` ကို function scope အတွင်းမှာသာ အသုံးပြုနိုင်သည်
    country := &quot;Myanmar&quot;
    population := 55000000

    fmt.Println(country, population)</code></pre>
<blockquote>
<p><strong>Warning:</strong> Go တွင် variable တစ်ခုကို ကြေညာပြီး မသုံးဘဲထားပါက compiler error တက်ပါမည်။ ထို့ကြောင့် မလိုအပ်သော variable များကို မကြေညာမိရန် သတိပြုပါ။</p>
</blockquote>
<h3 id="constants">Constants</h3>
<p>Constant ဆိုသည်မှာ program တစ်ခုလုံးတွင် တန်ဖိုး လုံးဝမပြောင်းလဲသော variable တစ်မျိုးဖြစ်သည်။ <code>const</code> keyword ကို အသုံးပြု၍ ကြေညာသည်။</p>
<pre><code class="lang-go">const PI = 3.14159
const AppVersion = &quot;1.0.2&quot;</code></pre>
<h2 id="-data-types">အခြေခံ Data Types</h2>
<p>Go သည် statically typed language ဖြစ်သောကြောင့် variable တိုင်းတွင် data type တစ်ခုရှိရပါမည်။</p>
<ul>
<li><p><strong>Numbers:</strong></p>
<ul>
<li><code>int</code>: ကိန်းပြည့် (e.g., <code>-10</code>, <code>0</code>, <code>100</code>)။ ကွန်ပျူတာ၏ architecture (32-bit or 64-bit) ပေါ်မူတည်၍ <code>int32</code> သို့မဟုတ် <code>int64</code> ဖြစ်သည်။</li>
<li><code>float64</code>: ဒသမကိန်း (e.g., <code>3.14</code>, <code>-0.01</code>)။</li>
<li><code>uint</code>: အပေါင်းကိန်းပြည့် (e.g., <code>0</code>, <code>10</code>, <code>200</code>)။</li>
</ul>
</li>
<li><p><strong>Strings:</strong></p>
<ul>
<li><code>string</code>: စာသားများကို ဖော်ပြရန် အသုံးပြုသည်။ Double quotes (<code>&quot;</code>) ကို အသုံးပြု၍ ရေးသားသည်။</li>
<li>ဥပမာ: <code>var message string = &quot;Hello from Go!&quot;</code></li>
</ul>
</li>
<li><p><strong>Booleans:</strong></p>
<ul>
<li><code>bool</code>: မှန်/မှား (<code>true</code>/<code>false</code>) တန်ဖိုးနှစ်မျိုးတည်းသာ ရှိသည်။</li>
<li>ဥပမာ: <code>var isReady bool = true</code></li>
</ul>
</li>
</ul>
<h2 id="operators">Operators</h2>
<p>Operators များသည် variables နှင့် values များအပေါ်တွင် လုပ်ဆောင်ချက်များ (operations) ကို ပြုလုပ်ရန် အသုံးပြုသော သင်္ကေတများဖြစ်သည်။</p>
<ul>
<li><strong>Arithmetic Operators:</strong> <code>+</code> (ပေါင်း), <code>-</code> (နှုတ်), <code>*</code> (မြှောက်), <code>/</code> (စား), <code>%</code> (အကြွင်း)</li>
<li><strong>Comparison Operators:</strong> <code>==</code> (ညီမျှ), <code>!=</code> (မညီမျှ), <code>&lt;</code> (ငယ်သည်), <code>&gt;</code> (ကြီးသည်), <code>&lt;=</code> (ငယ်သည် သို့မဟုတ် ညီမျှသည်), <code>&gt;=</code> (ကြီးသည် သို့မဟုတ် ညီမျှသည်)</li>
<li><strong>Logical Operators:</strong> <code>&amp;&amp;</code> (and), <code>||</code> (or), <code>!</code> (not)</li>
</ul>
<h2 id="comments-">Comments ရေးသားခြင်း</h2>
<p>Comment ဆိုသည်မှာ code ၏ လုပ်ဆောင်ချက်ကို ရှင်းပြရန် ရေးသားသော စာသားများဖြစ်ပြီး compiler က ၎င်းတို့ကို ထည့်သွင်းစဉ်းစားခြင်းမရှိပါ။</p>
<pre><code class="lang-go">// ဤသည်မှာ single-line comment ဖြစ်သည်။

/*
  ဤသည်မှာ
  multi-line comment ဖြစ်သည်။
*/</code></pre>
<h1 id="-control-flow-">အခန်း ၄: Control Flow (စီးဆင်းမှု ထိန်းချုပ်ခြင်း)</h1>
<p><code>Control Flow</code> ဆိုသည်မှာ program တစ်ခု၏ code များ မည်သည့်အစဉ်အတိုင်း လုပ်ဆောင်ရမည်ကို ထိန်းချုပ်သော statements များ ဖြစ်သည်။ Go တွင် <code>if</code>/<code>else</code>, <code>switch</code>, နှင့် <code>for</code> တို့ကို အသုံးပြု၍ program ၏ စီးဆင်းမှုကို ထိန်းချုပ်နိုင်ပါသည်။</p>
<h2 id="-if-else-statements"><code>if</code>/<code>else</code> Statements</h2>
<p><code>if</code>/<code>else</code> statement သည် အခြေအနေ (condition) တစ်ခု မှန်/မှား ပေါ်မူတည်၍ code block တစ်ခုကို run ရန် သို့မဟုတ် မ run ရန် ဆုံးဖြတ်ပေးသည်။</p>
<pre><code class="lang-mermaid">graph TD
    A[Start] --&gt; B{age &gt;= 18 ?};
    B -- True --&gt; C[Print &#39;You are an adult.&#39;];
    B -- False --&gt; D[Print &#39;You are a minor.&#39;];
    C --&gt; E[End];
    D --&gt; E;</code></pre>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

func main() {
    age := 20

    if age &gt;= 18 {
        fmt.Println(&quot;You are an adult.&quot;)
    } else {
        fmt.Println(&quot;You are a minor.&quot;)
    }

    // Statement နှင့်အတူ if ကို အတိုချုံး ရေးသားခြင်း
    // ဤနည်းလမ်းတွင် `num` variable ကို if/else block အတွင်းမှာသာ အသုံးပြုနိုင်သည်
    if num := 9; num &lt; 0 {
        fmt.Println(num, &quot;is negative&quot;)
    } else if num &lt; 10 {
        fmt.Println(num, &quot;has 1 digit&quot;)
    } else {
        fmt.Println(num, &quot;has multiple digits&quot;)
    }
}</code></pre>
<h2 id="-switch-statements"><code>switch</code> Statements</h2>
<p><code>switch</code> statement သည် variable တစ်ခု၏ တန်ဖိုးကို <code>case</code> များစွာနှင့် နှိုင်းယှဉ်စစ်ဆေးရန် အသုံးပြုသည်။ အခြား language များကဲ့သို့ <code>break</code> keyword ကို case တိုင်းတွင် ရေးရန်မလိုပါ။ Go တွင် case တစ်ခုပြီးဆုံးပါက switch မှ အလိုအလျောက် ထွက်ခွာပါသည်။</p>
<pre><code class="lang-mermaid">graph TD
    A[Start] --&gt; B{Check &#39;day&#39;};
    B -- &quot;Saturday or Sunday&quot; --&gt; C[&quot;Print &#39;It&#39;s the weekend!&#39;&quot;];
    B -- &quot;Monday&quot; --&gt; D[&quot;Print &#39;It&#39;s the start of the week.&#39;&quot;];
    B -- &quot;Other values (default)&quot; --&gt; E[&quot;Print &#39;It&#39;s a weekday.&#39;&quot;];
    C --&gt; F[End];
    D --&gt; F;
    E --&gt; F;</code></pre>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

func main() {
    day := &quot;Monday&quot;

    switch day {
    case &quot;Saturday&quot;, &quot;Sunday&quot;:
        fmt.Println(&quot;It&#39;s the weekend!&quot;)
    case &quot;Monday&quot;:
        fmt.Println(&quot;It&#39;s the start of the week.&quot;)
    default:
        fmt.Println(&quot;It&#39;s a weekday.&quot;)
    }

    // `fallthrough` keyword အသုံးပြုခြင်း
    // Case တစ်ခုမှန်ပါက အောက်ရှိ case ကိုပါ Condition ထပ်မစစ်ဆေးဘဲ ဆက်လက်လုပ်ဆောင်စေလိုလျှင် အသုံးပြုသည်။
    role := &quot;admin&quot;
    fmt.Println(&quot;Permissions for &quot; + role + &quot;:&quot;)

    switch role {
    case &quot;admin&quot;:
        fmt.Println(&quot;- Delete Users&quot;)
        fallthrough // admin ဖြစ်လျှင် edit လုပ်ခွင့်ပါ ရရှိစေရန် ဆက်သွားမည်
    case &quot;editor&quot;:
        fmt.Println(&quot;- Edit Content&quot;)
        fallthrough // editor ဖြစ်လျှင် view လုပ်ခွင့်ပါ ရရှိစေရန် ဆက်သွားမည်
    case &quot;viewer&quot;:
        fmt.Println(&quot;- View Content&quot;)
    default:
        fmt.Println(&quot;- No Access&quot;)
    }

    // တူညီသော Logic ကို `if/else` ဖြင့် ရေးသားလျှင် code များ ပိုရှည်နိုင်သည် (Comparison)
    fmt.Println(&quot;\n--- Same Logic with if/else ---&quot;)
    if role == &quot;admin&quot; {
        fmt.Println(&quot;- Delete Users&quot;)
        fmt.Println(&quot;- Edit Content&quot;) // Code repeating
        fmt.Println(&quot;- View Content&quot;) // Code repeating
    } else if role == &quot;editor&quot; {
        fmt.Println(&quot;- Edit Content&quot;)
        fmt.Println(&quot;- View Content&quot;) // Code repeating
    } else if role == &quot;viewer&quot; {
        fmt.Println(&quot;- View Content&quot;)
    } else {
        fmt.Println(&quot;- No Access&quot;)
    }
}</code></pre>
<h2 id="-for-loops"><code>for</code> Loops</h2>
<p>Go တွင် loop အမျိုးအစား တစ်မျိုးတည်းသာရှိပြီး ၎င်းမှာ <code>for</code> loop ဖြစ်သည်။ သို့သော် <code>for</code> loop ကို ပုံစံအမျိုးမျိုးဖြင့် အသုံးပြုနိုင်ပါသည်။</p>
<p><strong>1. Classic <code>for</code> loop (C-style)</strong></p>
<pre><code class="lang-go">for i := 0; i &lt; 5; i++ {
    fmt.Println(i)
}</code></pre>
<p><strong>2. <code>while</code> loop ကဲ့သို့ အသုံးပြုခြင်း</strong></p>
<pre><code class="lang-go">n := 0
for n &lt; 5 {
    fmt.Println(n)
    n++
}</code></pre>
<p><strong>3. <code>for-range</code> loop (Slices, Maps, Arrays များအတွက်)</strong></p>
<pre><code class="lang-go">fruits := []string{&quot;Apple&quot;, &quot;Banana&quot;, &quot;Cherry&quot;}
for index, value := range fruits {
    fmt.Printf(&quot;Index: %d, Value: %s\n&quot;, index, value)
}

// index သို့မဟုတ် value မလိုအပ်ပါက blank identifier (_) ကို အသုံးပြုနိုင်သည်
for _, value := range fruits {
    fmt.Println(&quot;Value:&quot;, value)
}</code></pre>
<h1 id="-composite-types-arrays-slices-and-maps">အခန်း ၅: Composite Types - Arrays, Slices, and Maps</h1>
<p>ယခုအခန်းတွင် Go ၏ အသုံးအများဆုံး composite data types များဖြစ်သော Arrays, Slices, နှင့် Maps တို့အကြောင်းကို လေ့လာသွားပါမည်။ ဤ data types များသည် data အစုအဝေးများကို စုစည်းသိမ်းဆည်းရန်အတွက် အလွန်အရေးပါပါသည်။</p>
<h2 id="1-arrays">1. Arrays</h2>
<p>Array ဆိုသည်မှာ <strong>data type တစ်မျိုးတည်းကိုသာ</strong> သိမ်းဆည်းနိုင်သော၊ <strong>အရွယ်အစား (size) ပုံသေ</strong> သတ်မှတ်ထားသည့် data collection တစ်ခုဖြစ်သည်။ Array တစ်ခုကို ကြေညာလိုက်သည်နှင့် ၎င်း၏ အရွယ်အစားကို ပြောင်းလဲ၍မရပါ။</p>
<p>Go တွင် Array ကို Slices များလောက် အသုံးမများသော်လည်း၊ Slices ၏ အလုပ်လုပ်ပုံကို နားလည်ရန်အတွက် Array သည် အခြေခံကျပါသည်။</p>
<pre><code class="lang-mermaid">graph TD
    subgraph &quot;Array: var numbers [5]int&quot;
        direction LR
        A[0: 10] --- B[1: 0] --- C[2: 0] --- D[3: 0] --- E[4: 50]
    end
    style A fill:#f9f,stroke:#333,stroke-width:2px
    style E fill:#f9f,stroke:#333,stroke-width:2px</code></pre>
<p><strong>ဥပမာ Code:</strong></p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

func main() {
    // အရွယ်အစား 5 ရှိသော integer array တစ်ခုကို ကြေညာခြင်း
    // ကနဦးတွင် တန်ဖိုးအားလုံးသည် zero-value (int အတွက် 0) ဖြစ်သည်
    var numbers [5]int
    fmt.Println(&quot;Initial Array:&quot;, numbers) // Output: [0 0 0 0 0]

    // Index ကို အသုံးပြု၍ တန်ဖိုးများ ထည့်သွင်းခြင်း
    numbers[0] = 10
    numbers[4] = 50

    fmt.Println(&quot;After assignment:&quot;, numbers) // Output: [10 0 0 0 50]
    fmt.Println(&quot;Length:&quot;, len(numbers))   // Output: 5

    // ကြေညာစဉ် တန်ဖိုးများ တခါတည်းထည့်သွင်းခြင်း
    primes := [3]int{2, 3, 5}
    fmt.Println(&quot;Primes Array:&quot;, primes) // Output: [2 3 5]
}</code></pre>
<h2 id="2-slices">2. Slices</h2>
<p>Slice သည် Array အပေါ်တွင် တည်ဆောက်ထားသော ပိုမို flexible ဖြစ်ပြီး အစွမ်းထက်သည့် data structure ဖြစ်သည်။ Array ကဲ့သို့ အရွယ်အစား ပုံသေမဟုတ်ဘဲ <strong>dynamic (ပြောင်းလွယ်ပြင်လွယ်)</strong> ဖြစ်သောကြောင့် Go developer များ အသုံးအများဆုံးဖြစ်သည်။</p>
<p>Slice သည် အပိုင်းသုံးပိုင်းဖြင့် ဖွဲ့စည်းထားသည်-</p>
<ol>
<li><strong>Pointer:</strong> နောက်ကွယ်ရှိ array (underlying array) ၏ element တစ်ခုကို ညွှန်ပြနေသော pointer။</li>
<li><strong>Length (<code>len()</code>):</strong> Slice ထဲတွင် လက်ရှိရှိနေသော element အရေအတွက်။</li>
<li><strong>Capacity (<code>cap()</code>):</strong> Slice ၏ pointer စတင်ညွှန်ပြသည့်နေရာမှ underlying array ၏ အဆုံးအထိရှိသော element အရေအတွက်။</li>
</ol>
<h3 id="slice-length-and-capacity">Slice, Length, and Capacity</h3>
<pre><code class="lang-mermaid">graph TD
    subgraph &quot;Underlying Array (Size: 8)&quot;
        direction LR
        A[10] --- B[20] --- C[30] --- D[40] --- E[50] --- F[60] --- G[70] --- H[80]
    end

    subgraph &quot;Slice: array[2:5]&quot;
        direction LR
        C_slice(30) --- D_slice(40) --- E_slice(50)
    end

    Pointer[&quot;Slice Pointer&quot;] --&gt; C

    subgraph &quot;Slice Properties&quot;
        Length[&quot;Length = 3&lt;br/&gt;(30, 40, 50)&quot;]
        Capacity[&quot;Capacity = 6&lt;br/&gt;(30, 40, 50, 60, 70, 80)&quot;]
    end</code></pre>
<h3 id="-make-function-slice-"><code>make()</code> Function အသုံးပြု၍ Slice တည်ဆောက်ခြင်း</h3>
<p>Slice များကို <code>make()</code> function အသုံးပြု၍လည်း တည်ဆောက်နိုင်သည်။ ၎င်းသည် slice တစ်ခုကို ဖန်တီးရာတွင် <code>length</code> နှင့် <code>capacity</code> ကို ကြိုတင်သတ်မှတ်ထားလိုသည့်အခါ အလွန်အသုံးဝင်သည်။</p>
<pre><code class="lang-go">// make([]Type, len, cap)
// Length 5 နှင့် Capacity 10 ရှိသော slice တစ်ခုကို ဖန်တီးခြင်း
scores := make([]int, 5, 10) 

names := make([]string, 5) // len=5, cap=5</code></pre>
<p><strong>Length vs Capacity: အဆောက်အဦး ဥပမာ (Analogy)</strong></p>
<p><strong>အဆောက်အဦးတစ်ခုတွင် အခန်း ၁၀ ခန်းရှိသည် (Capacity = 10)</strong></p>
<ul>
<li>သို့သော် ပထမ ၅ ခန်းကိုသာ ပရိဘောဂများထည့်သွင်းပြီး အသုံးပြုရန် အဆင်သင့်ပြင်ထားသည် (Length = 5)</li>
<li>ကျန်ရှိသော ၅ ခန်းသည် အဆောက်အဦးထဲတွင် ရှိနေသော်လည်း &quot;ဖွင့်လှစ်ခြင်း&quot; မရှိသေးပါ (Reserved space)</li>
</ul>
<p><strong>Visual representation:</strong></p>
<pre><code class="lang-text">[0] [1] [2] [3] [4] | [5] [6] [7] [8] [9]
 0   0   0   0   0  |  ?   ?   ?   ?   ?
├─────────────────┤  ├─────────────────┤
   Length = 5          Reserved space</code></pre>
<p><strong>Example Code:</strong></p>
<pre><code class="lang-go">scores := make([]int, 5, 10)

// 1. Initialized ဖြစ်ပြီးသား ပထမ ၅ ခန်း (Index 0-4) ကို ချက်ချင်းအသုံးပြုနိုင်သည်
scores[0] = 95
scores[1] = 87
scores[4] = 92
// scores[5] = 100 // Error: index out of range (အခန်းမဖွင့်ရသေးသောကြောင့် သုံးမရပါ)

fmt.Println(scores[0])  // Output: 95
fmt.Println(scores)     // Output: [95 87 0 0 92]

// 2. append() ကိုသုံးမှသာ နောက်ထပ်အခန်းများကို တစ်ခန်းချင်းစီ ထပ်ဖွင့်နိုင်သည်
scores = append(scores, 100)  // ယခုအခါ length သည် 6 ဖြစ်သွားပြီ (Index 5 ပွင့်သွားပြီ)
scores = append(scores, 200)  // ယခုအခါ length သည် 7 ဖြစ်သွားပြီ (Index 6 ပွင့်သွားပြီ)

fmt.Println(scores)       // Output: [95 87 0 0 92 100 200]
fmt.Println(len(scores))  // 7 (ဖွင့်ပြီးသားအခန်း)
fmt.Println(cap(scores))  // 10 (ရှိရင်းစွဲအခန်း)</code></pre>
<h3 id="-append-slice-element-"><code>append</code> ဖြင့် Slice ကို Element ထပ်ထည့်ခြင်း</h3>
<p><code>append</code> function သည် slice ၏ အရေးကြီးဆုံး အစိတ်အပိုင်းဖြစ်သည်။ ၎င်း၏ အလုပ်လုပ်ပုံကို <code>capacity</code> နှင့် ဆက်စပ်၍ နားလည်ရန် အရေးကြီးသည်။</p>
<p><strong>Case 1: Append within Capacity (Capacity အတွင်း Element ထပ်ထည့်ခြင်း)</strong></p>
<p>Slice ၏ <code>length</code> သည် <code>capacity</code> ထက်ငယ်နေသေးလျှင် <code>append</code> လုပ်သောအခါ <strong>မူလ underlying array</strong> ၏ နေရာလွတ်တွင်ပင် element အသစ်ကို ထည့်သွင်းသည်။</p>
<pre><code class="lang-mermaid">sequenceDiagram
    participant Slice
    participant &quot;Underlying Array&quot;

    Slice-&gt;&gt;&quot;Underlying Array&quot;: append(&quot;D&quot;)
    Note right of Slice: len &lt; cap, so append in place.
    &quot;Underlying Array&quot;--&gt;&gt;Slice: New slice points to same array</code></pre>
<p><strong>Case 2: Append exceeding Capacity (Capacity ကျော်လွန်၍ Element ထပ်ထည့်ခြင်း)</strong></p>
<p>Slice ၏ <code>length</code> သည် <code>capacity</code> နှင့် တူညီနေချိန်တွင် <code>append</code> လုပ်သောအခါ Go runtime သည်-</p>
<ol>
<li><strong>Array အသစ်တစ်ခု</strong> (များသောအားဖြင့် လက်ရှိ capacity ၏ နှစ်ဆ) ကို memory တွင် တည်ဆောက်သည်။</li>
<li>Element အဟောင်းများအားလုံးကို array အသစ်သို့ <strong>copy ကူးထည့်သည်</strong>။</li>
<li>Element အသစ်ကို array အသစ်၏ အဆုံးတွင် ထည့်သွင်းသည်။</li>
<li>Slice ၏ pointer ကို <strong>array အသစ်ဆီသို့</strong> ပြောင်းလဲ ညွှန်ပြစေသည်။</li>
</ol>
<pre><code class="lang-mermaid">sequenceDiagram
    participant Slice
    participant &quot;Old Array&quot;
    participant &quot;New (Larger) Array&quot;

    Slice-&gt;&gt;Slice: append(&quot;E&quot;)
    Note right of Slice: len == cap, must reallocate!

    Slice-&gt;&gt;&quot;New (Larger) Array&quot;: 1. Create new, larger array
    Slice-&gt;&gt;&quot;Old Array&quot;: 2. Copy elements (A, B, C, D)
    &quot;Old Array&quot;--&gt;&gt;&quot;New (Larger) Array&quot;: Elements copied
    Slice-&gt;&gt;&quot;New (Larger) Array&quot;: 3. Add new element (&quot;E&quot;)

    Note left of &quot;Old Array&quot;: Old array is now unused by this slice.</code></pre>
<p><strong>ဥပမာ Code (Length &amp; Capacity):</strong></p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

func main() {
    // 1. Underlying array တစ်ခု ဖန်တီးခြင်း
    numbersArray := [6]int{10, 20, 30, 40, 50, 60}
    fmt.Println(&quot;Underlying Array:&quot;, numbersArray)

    // 2. Array မှ slice တစ်ခု ဖန်တီးခြင်း (index 2 မှ 4 မတိုင်ခင်အထိ)
    mySlice := numbersArray[2:4] // [30, 40]

    fmt.Printf(&quot;Slice: %v, Length: %d, Capacity: %d&quot;, mySlice, len(mySlice), cap(mySlice))
    // Capacity: index 2 မှ array အဆုံးထိ ရေတွက်မည် (30, 40, 50, 60) -&gt; 4 ခု

    // 3. Append within Capacity
    mySlice = append(mySlice, 70)
    fmt.Println(&quot;\n--- After appending 70 (within capacity) ---&quot;)
    fmt.Printf(&quot;Slice: %v, Length: %d, Capacity: %d\n&quot;, mySlice, len(mySlice), cap(mySlice))
    // Underlying array ပါ ပြောင်းလဲသွားသည်ကို သတိပြုပါ
    fmt.Println(&quot;Underlying Array is now:&quot;, numbersArray) // Output: [10 20 30 40 70 60]

    // 4. Append exceeding Capacity
    // လက်ရှိ cap = 4, len = 3 ဖြစ်နေသေးသည်
    mySlice = append(mySlice, 80) // cap ပြည့်သွားပြီ
    mySlice = append(mySlice, 90) // cap ကျော်လွန်သွားပြီ

    fmt.Println(&quot;\n--- After appending 80 and 90 (exceeding capacity) ---&quot;)
    // Go က array အသစ်တစ်ခု (size 8) ကို တည်ဆောက်ပြီး data တွေ copy ကူးထည့်ပါမည်။
    fmt.Printf(&quot;Slice: %v, Length: %d, Capacity: %d\n&quot;, mySlice, len(mySlice), cap(mySlice))

    // array အသစ်ကို ညွှန်းဆိုသွားသောကြောင့် မူလ array ကို ထိခိုက်တော့မည် မဟုတ်ပါ။
    fmt.Println(&quot;Underlying Array remains unchanged:&quot;, numbersArray)
}</code></pre>
<h2 id="3-maps">3. Maps</h2>
<p>Map ဆိုသည်မှာ <strong>key-value pair</strong> များဖြင့် data များကို သိမ်းဆည်းသော <strong>unordered collection</strong> တစ်ခုဖြစ်သည်။ အခြား language များရှိ hash tables သို့မဟုတ် dictionaries များနှင့် ဆင်တူသည်။</p>
<pre><code class="lang-mermaid">graph TD
    subgraph &quot;Map: ages&quot;
        direction LR
        K1[&quot;Aung Aung&quot;] --&gt; V1[25]
        K2[&quot;Ma Ma&quot;] --&gt; V2[30]
        K3[&quot;Kyaw Kyaw&quot;] --&gt; V3[28]
    end</code></pre>
<p><strong>အရေးကြီးသော အချက်:</strong> Map ထဲမှ data များကို <code>for...range</code> loop ဖြင့် ပြန်ထုတ်သည့်အခါ ရရှိလာသော အစီအစဉ်သည် data ထည့်သွင်းခဲ့သည့် အစီအစဉ်အတိုင်း ဖြစ်မည်ဟု <strong>အာမမခံပါ</strong>။ အဘယ်ကြောင့်ဆိုသော် Map သည် hash table ကို အခြေခံထားပြီး performance အတွက် iteration order ကို တမင် random ပြုလုပ်ထားသောကြောင့် ဖြစ်သည်။</p>
<p><strong>ဥပမာ Code:</strong></p>
<pre><code class="lang-go">package main

import (
    &quot;fmt&quot;
    &quot;sort&quot;
)

func main() {
    // string key နှင့် int value ရှိသော map တစ်ခုကို ကြေညာပြီး တန်ဖိုးထည့်ခြင်း
    ages := map[string]int{
        &quot;Aung Aung&quot;: 25,
        &quot;Ma Ma&quot;:     30,
    }
    fmt.Println(&quot;Initial Map:&quot;, ages)

    // Element တစ်ခုကို ဖျက်ခြင်း
    delete(ages, &quot;Ma Ma&quot;)
    fmt.Println(&quot;After delete:&quot;, ages)

    // Key ရှိမရှိ စစ်ဆေးခြင်း
    // `val` တွင် value ကို ရရှိပြီး `ok` တွင် key ရှိ/မရှိ (true/false) ကို ရရှိမည်
    val, ok := ages[&quot;Kyaw Kyaw&quot;]
    if ok {
        fmt.Println(&quot;Kyaw Kyaw&#39;s age is&quot;, val)
    } else {
        fmt.Println(&quot;Kyaw Kyaw not found.&quot;)
    }

    // --- Map Iteration ---
    testScores := map[string]int{
        &quot;Charlie&quot;: 88,
        &quot;Alice&quot;:   95,
        &quot;Bob&quot;:     72,
    }

    fmt.Println(&quot;\nUnordered Iteration:&quot;)
    // ဤ loop ကို run တိုင်း ရလဒ်အစီအစဉ် ပြောင်းလဲနိုင်သည်
    for name, score := range testScores {
        fmt.Printf(&quot;Name: %s, Score: %d&quot;, name, score)
    }

    // --- Sorted Iteration (အစီအစဉ်တကျ ပြန်ထုတ်ခြင်း) ---
    // 1. Key များကို slice တစ်ခုထဲ ထည့်ပါ
    var names []string
    for name := range testScores {
        names = append(names, name)
    }
    // 2. Slice ကို sort လုပ်ပါ
    sort.Strings(names)

    fmt.Println(&quot;Sorted Iteration:&quot;)
    // 3. Sort လုပ်ပြီးသား slice ကို loop ပတ်ပြီး map မှ value များကို ထုတ်ပါ
    for _, name := range names {
        fmt.Printf(&quot;Name: %s, Score: %d&quot;, name, testScores[name])
    }
}</code></pre>
<h1 id="-structs-and-methods">အခန်း ၆: Structs and Methods</h1>
<p>ယခုအခန်းတွင် Go ၏ အစွမ်းထက်သော feature တစ်ခုဖြစ်သည့် <code>struct</code> နှင့် <code>method</code> တို့အကြောင်းကို လေ့လာသွားပါမည်။ Struct သည် data type အမျိုးမျိုးကို စုစည်း၍ ကိုယ်ပိုင် custom data type အသစ်များ တည်ဆောက်ရန် အသုံးပြုပြီး၊ Method များသည် ထို struct များနှင့် သက်ဆိုင်သော လုပ်ဆောင်ချက် (behavior) များကို သတ်မှတ်ပေးပါသည်။</p>
<h2 id="1-struct-custom-data-types-">1. Struct (Custom Data Types)</h2>
<p>Struct (structure) ဆိုသည်မှာ data type အမျိုးမျိုးရှိနိုင်သော <strong>fields</strong> (အချက်အလက်များ) ကို စုစည်းထားသည့် collection တစ်ခုဖြစ်သည်။ ဥပမာအားဖြင့်၊ လူတစ်ယောက် (<code>Person</code>) ကို ဖော်ပြရန်အတွက် နာမည် (<code>string</code>), အသက် (<code>int</code>) စသည်တို့ကို <code>Person</code> struct တစ်ခုတည်းတွင် စုစည်းထားနိုင်ပါသည်။</p>
<pre><code class="lang-mermaid">graph TD
    subgraph &quot;type Person struct&quot;
        FirstName[FirstName: string]
        LastName[LastName: string]
        Age[Age: int]
    end</code></pre>
<p><strong>ဥပမာ Code:</strong></p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

// &#39;Person&#39; အမည်ဖြင့် custom data type အသစ်တစ်ခု တည်ဆောက်ခြင်း
type Person struct {
    FirstName string
    LastName  string
    Age       int
}

func main() {
    // Person struct မှ variable တစ်ခု တည်ဆောက်ခြင်း
    p1 := Person{
        FirstName: &quot;Aung&quot;,
        LastName:  &quot;Kyaw&quot;,
        Age:       30,
    }

    fmt.Println(&quot;Person 1:&quot;, p1)
    fmt.Println(&quot;First Name:&quot;, p1.FirstName) // field ကို dot (.) ဖြင့် ခေါ်သုံးခြင်း

    // field တန်ဖိုးကို ပြောင်းလဲခြင်း
    p1.Age = 31
    fmt.Println(&quot;Updated Age:&quot;, p1.Age)
}</code></pre>
<h2 id="2-methods-struct-functions-">2. Methods (Struct နှင့် သက်ဆိုင်သော Functions)</h2>
<p>Method ဆိုသည်မှာ struct တစ်ခုနှင့် သီးသန့်သက်ဆိုင်သော function တစ်မျိုးဖြစ်သည်။ ၎င်းသည် function ကြေညာရာတွင် <code>func</code> keyword နှင့် function name အကြား၌ <strong>&quot;receiver&quot;</strong> ဟုခေါ်သော argument တစ်ခု ပိုမိုပါဝင်သည်။</p>
<p>Receiver အမျိုးအစား နှစ်မျိုးရှိသည်-</p>
<ol>
<li><strong>Value Receiver:</strong> Struct ၏ <strong>မိတ္တူ (copy)</strong> ကိုသာ ရရှိသည်။ Method အတွင်း ပြောင်းလဲမှုများသည် မူလ struct ကို <strong>မထိခိုက်ပါ</strong>။</li>
<li><strong>Pointer Receiver:</strong> Struct ၏ <strong>မူရင်း memory address (pointer)</strong> ကို ရရှိသည်။ Method အတွင်း ပြောင်းလဲမှုများသည် မူလ struct ကို <strong>တိုက်ရိုက် ထိခိုက်ပြောင်းလဲစေသည်</strong>။</li>
</ol>
<h3 id="value-receiver-vs-pointer-receiver">Value Receiver vs. Pointer Receiver</h3>
<pre><code class="lang-mermaid">graph TD
    subgraph &quot;Value Receiver: func (p Person) updateAge()&quot;
        direction LR
        Original_V[&quot;Original Person (Age: 30)&quot;] --&gt;|&quot;1. Makes a copy&quot;| Copy_V[&quot;Copy of Person (Age: 30)&quot;]
        Copy_V --&gt;|&quot;2. Method runs on copy&quot;| Modified_V[&quot;Copy of Person (Age: 31)&quot;]
        Original_V -.-&gt;|&quot;3. Original is UNCHANGED&quot;| Original_V
    end

    subgraph &quot;Pointer Receiver: func (p *Person) updateAge()&quot;
        direction LR
        Original_P[&quot;Original Person (Age: 30)&quot;] --&gt;|&quot;1. Passes a pointer&quot;| Pointer[&quot;Pointer to Original&quot;]
        Pointer --&gt;|&quot;2. Method runs on original&quot;| Modified_P[&quot;Original Person (Age: 31)&quot;]
        Original_P -.-&gt;|&quot;3. Original is CHANGED&quot;| Modified_P
    end

    style Original_V fill:#FFDDC1
    style Modified_V fill:#FFDDC1
    style Original_P fill:#D4E4F7
    style Modified_P fill:#D4E4F7</code></pre>
<p><strong>Pointer Receiver ကို ဘာကြောင့်/ဘယ်အချိန် သုံးသင့်သလဲ?</strong></p>
<ol>
<li><strong>To modify state:</strong> Method အတွင်းမှ struct ၏ မူလတန်ဖိုးများကို ပြောင်းလဲရန် မဖြစ်မနေ သုံးရမည်။</li>
<li><strong>Efficiency:</strong> Struct အရွယ်အစားကြီးမားပါက data များစွာကို copy ကူးခြင်းမှ ရှောင်ရှားရန် pointer ဖြင့် pass လုပ်ခြင်းက ပိုမိုမြန်ဆန်ပြီး memory သက်သာစေသည်။</li>
</ol>
<p><strong>ဥပမာ Code:</strong></p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

type Person struct {
    FirstName string
    Age       int
}

// (p Person) -&gt; Value Receiver
func (p Person) Greet() {
    fmt.Printf(&quot;Hello, my name is %s and I am %d years old.\n&quot;, p.FirstName, p.Age)
    p.Age = 99 // ဤပြောင်းလဲမှုသည် copy ကိုသာ ထိခိုက်ပြီး မူရင်း struct ကို မပြောင်းလဲပါ
}

// (p *Person) -&gt; Pointer Receiver
func (p *Person) SetAge(newAge int) {
    p.Age = newAge
}

func main() {
    p := Person{FirstName: &quot;Su Myat&quot;, Age: 25}

    p.Greet()
    fmt.Println(&quot;Age after Greet():&quot;, p.Age) // Output: 25 (မပြောင်းလဲပါ)

    p.SetAge(26)
    fmt.Println(&quot;Age after SetAge():&quot;, p.Age) // Output: 26 (ပြောင်းလဲသွားသည်)
}</code></pre>
<h2 id="3-embedded-structs-composition-">3. Embedded Structs (Composition)</h2>
<p>Go တွင် class inheritance (အမွေဆက်ခံခြင်း) မရှိပါ။ သို့သော် struct တစ်ခုကို အခြား struct တစ်ခုထဲတွင် ထည့်သွင်းခြင်း (<strong>embedding</strong>) ဖြင့် <strong>composition</strong> ကို အားပေးသည်။</p>
<pre><code class="lang-mermaid">graph TD
    subgraph &quot;type Employee struct&quot;
        Position[&quot;Position: string&quot;]
        Person[&quot;Person (embedded)&quot;]
        Contact[&quot;ContactInfo (embedded)&quot;]
    end

    subgraph &quot;type Person struct&quot;
        FirstName[&quot;FirstName: string&quot;]
        LastName[&quot;LastName: string&quot;]
    end

    subgraph &quot;type ContactInfo struct&quot;
        Email[&quot;Email: string&quot;]
        Phone[&quot;Phone: string&quot;]
    end

    Person --&gt; FirstName &amp; LastName
    Contact --&gt; Email &amp; Phone

    subgraph &quot;Usage: emp.FirstName&quot;
        emp[Employee Instance] --&gt;|Accesses promoted field| FirstName
    end</code></pre>
<p><strong>ဥပမာ Code:</strong></p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

type ContactInfo struct {
    Email string
    Phone string
}

type Person struct {
    FirstName string
    LastName  string
}

type Employee struct {
    Position string
    Person      // Person struct ကို embed လုပ်ခြင်း
    ContactInfo // ContactInfo struct ကို embed လုပ်ခြင်း
}

func main() {
    emp := Employee{
        Position: &quot;Software Engineer&quot;,
        Person: Person{
            FirstName: &quot;Thura&quot;,
            LastName:  &quot;Linn&quot;,
        },
        ContactInfo: ContactInfo{
            Email: &quot;thura.linn@example.com&quot;,
            Phone: &quot;09123456789&quot;,
        },
    }

    fmt.Println(&quot;Employee&#39;s First Name:&quot;, emp.FirstName)
    fmt.Println(&quot;Employee&#39;s Email:&quot;, emp.Email)
    fmt.Println(&quot;Full Info:&quot;, emp)
}</code></pre>
<h2 id="4-constructor-functions">4. Constructor Functions</h2>
<p>Go တွင် class မရှိသကဲ့သို့ <code>constructor</code> ဟူ၍လည်း သီးသန့်မရှိပါ။ သို့သော် struct အသစ်တစ်ခု ဆောက်လုပ်ရာတွင် လွယ်ကူစေရန်နှင့် default value များ သတ်မှတ်ပေးနိုင်ရန် <strong>Factory Pattern</strong> သဘောတရားဖြစ်သည့် Help function များကို ရေးသားလေ့ရှိကြသည်။ </p>
<p>Convention အရ ထို helper function များကို <code>New</code> ဟု အစပြုလေ့ရှိသည်။</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

type Person struct {
    Name string
    Age  int
}

// Constructor function
// နာမည်ပြောင်းလို့ရသော်လည်း New သို့မဟုတ် NewPerson ဟု ပေးလေ့ရှိကြသည်
func NewPerson(name string, age int) *Person {
    // Default logic များကို ဤနေရာတွင် ထည့်သွင်းနိုင်သည်
    if age &lt; 0 {
        age = 0
    }
    return &amp;Person{
        Name: name,
        Age:  age,
    }
}

func main() {
    // Constructor ကို အသုံးပြု၍ struct တည်ဆောက်ခြင်း
    p := NewPerson(&quot;Mg Mg&quot;, 25)
    fmt.Println(p)
}</code></pre>
<h2 id="5-struct-tags">5. Struct Tags</h2>
<p>Struct tag များသည် struct field များ၏ metadata (အချက်အလက်အပို) များကို သိမ်းဆည်းပေးထားခြင်းဖြစ်သည်။ ၎င်းတို့ကို <code>reflection</code> အသုံးပြု၍ run-time တွင် ဖတ်ရှုအလုပ်လုပ်နိုင်သည်။</p>
<p>အသုံးအများဆုံး ဥပမာမှာ <strong>JSON</strong> data များနှင့် အလုပ်လုပ်ရာတွင် ဖြစ်သည်။</p>
<pre><code class="lang-go">package main

import (
    &quot;encoding/json&quot;
    &quot;fmt&quot;
)

type Student struct {
    // JSON သို့ပြောင်းလျှင် &quot;first_name&quot; ဟူသော key ကို သုံးမည်
    FirstName string `json:&quot;first_name&quot;`

    // JSON သို့ပြောင်းလျှင် &quot;last_name&quot; ဟူသော key ကို သုံးမည်
    LastName  string `json:&quot;last_name&quot;`

    // &quot;omitempty&quot; သည် value မရှိလျှင် (zero-value) JSON ထဲတွင် ထည့်မသွင်းဟု ဆိုလိုသည်
    Age       int    `json:&quot;age,omitempty&quot;`

    // &quot;-&quot; သည် ဤ field ကို JSON အဖြစ် မပြောင်းလဲဟု ဆိုလိုသည်
    Password  string `json:&quot;-&quot;`
}

func main() {
    s := Student{
        FirstName: &quot;Su Su&quot;,
        LastName:  &quot;Hlaing&quot;,
        Password:  &quot;secret123&quot;,
    }

    // Struct မှ JSON သို့ ပြောင်းခြင်း (Marshaling)
    jsonData, _ := json.Marshal(s)
    fmt.Println(string(jsonData))
    // Output: {&quot;first_name&quot;:&quot;Su Su&quot;,&quot;last_name&quot;:&quot;Hlaing&quot;}
    // Age မပါဝင်ခြင်းမှာ 0 (zero-value) ဖြစ်ပြီး omitempty ပါသောကြောင့်ဖြစ်သည်
    // Password မပါဝင်ခြင်းမှာ &quot;-&quot; သတ်မှတ်ထားသောကြောင့်ဖြစ်သည်
}</code></pre>
<h1 id="-functions">အခန်း ၇: Functions</h1>
<p>Function ဆိုသည်မှာ သီးခြားလုပ်ဆောင်ချက်တစ်ခုကို လုပ်ဆောင်ရန်အတွက် စုစည်းရေးသားထားသော code block တစ်ခုဖြစ်သည်။ Functions များသည် code များကို ပြန်လည်အသုံးပြုနိုင်ရန် (reusability)၊ စနစ်တကျခွဲခြားရန် (organization) နှင့် ဖတ်ရှုရလွယ်ကူစေရန် (readability) အတွက် အဓိကကျသော အစိတ်အပိုင်းများ ဖြစ်ကြသည်။</p>
<h2 id="function-">Function ကြေညာခြင်း နှင့် ခေါ်ယူအသုံးပြုခြင်း</h2>
<p>Go တွင် function တစ်ခုကို <code>func</code> keyword ဖြင့် ကြေညာသည်။ Function တစ်ခုတွင် အမည်၊ parameters (optional)၊ return types (optional) နှင့် code block (body) တို့ ပါဝင်သည်။</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

// Title Case (အကြီးဖြင့်စခြင်း) -&gt; Exported (Public)
// Package အပြင်မှ လှမ်းခေါ်သုံးနိုင်သည်
func SayHello() {
    fmt.Println(&quot;Hello (Public)!&quot;)
}

// Lower Case (အသေးဖြင့်စခြင်း) -&gt; Unexported (Private)
// Package အတွင်းတွင်သာ သုံးနိုင်သည်
func sayHello() {
    fmt.Println(&quot;Hello (Private)!&quot;)
}

func main() {
    // function ကို ခေါ်ယူအသုံးပြုခြင်း
    sayHello()
}</code></pre>
<blockquote>
<p><strong>မှတ်ချက်:</strong> Go တွင် <code>public</code> / <code>private</code> keyword များ မရှိပါ။ Function အမည်၏ <strong>ပထမစာလုံး အကြီး/အသေး (Capitalization)</strong> ပေါ်မူတည်၍ ခွဲခြားပါသည်။</p>
</blockquote>
<h2 id="parameters-return-values">Parameters နှင့် Return Values</h2>
<p>Functions များသည် တန်ဖိုးများကို input အဖြစ် (parameters) လက်ခံနိုင်ပြီး၊ လုပ်ဆောင်ချက်များ ပြီးဆုံးသောအခါ တန်ဖိုးများကို output အဖြစ် (return values) ပြန်ပေးနိုင်ပါသည်။</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

// `a` နှင့် `b` (int type) ကို parameter အဖြစ် လက်ခံပြီး
// `int` type တန်ဖိုးတစ်ခုကို return ပြန်ပေးသော function
func add(a int, b int) int {
    return a + b
}

// Parameter type တွေ တူညီပါက အတို ရေးနိုင်သည်
func subtract(a, b int) int {
    return a - b
}

func main() {
    sum := add(10, 5)
    fmt.Println(&quot;Sum:&quot;, sum)

    difference := subtract(10, 5)
    fmt.Println(&quot;Difference:&quot;, difference)
}</code></pre>
<h2 id="multiple-return-values">Multiple Return Values</h2>
<p>Go ၏ အစွမ်းထက်သော feature တစ်ခုမှာ function တစ်ခုမှ တန်ဖိုးများစွာကို တစ်ပြိုင်နက်တည်း return ပြန်ပေးနိုင်ခြင်းဖြစ်သည်။ ဤ feature ကို error handling ပြုလုပ်ရာတွင် တွင်ကျယ်စွာ အသုံးပြုလေ့ရှိသည်။ ပုံမှန်အားဖြင့် function သည် ရလဒ် (result) နှင့် error တစ်ခုကို အတူတကွ ပြန်ပေးလေ့ရှိသည်။</p>
<pre><code class="lang-go">package main

import (
    &quot;fmt&quot;
    &quot;errors&quot;
)

// int နှင့် error ကို multiple values အဖြစ် return ပြန်ပေးသည်
func divide(a, b float64) (float64, error) {
    if b == 0 {
        // 0 ဖြင့် စားပါက error message တစ်ခုကို ပြန်ပေးမည်
        return 0, errors.New(&quot;cannot divide by zero&quot;)
    }
    // အောင်မြင်ပါက ရလဒ်နှင့် nil (error မရှိ) ကို ပြန်ပေးမည်
    return a / b, nil
}

func main() {
    result, err := divide(10.0, 2.0)
    if err != nil {
        fmt.Println(&quot;Error:&quot;, err)
    } else {
        fmt.Println(&quot;Result:&quot;, result)
    }

    result, err = divide(10.0, 0)
    if err != nil {
        fmt.Println(&quot;Error:&quot;, err)
    } else {
        fmt.Println(&quot;Result:&quot;, result)
    }
}</code></pre>
<h2 id="named-return-values">Named Return Values</h2>
<p>Go ၏ ထူးခြားချက်တစ်ခုမှာ Return ပြန်မည့် variable များကို function signature တွင် အမည်နှင့်တကွ ကြိုတင်ကြေညာထားနိုင်ခြင်း ဖြစ်သည်။ ၎င်းသည် code ကို ပိုမိုရှင်းလင်းစေပြီး <code>return</code> ဟု ရေးလိုက်ရုံဖြင့် (naked return) လက်ရှိတန်ဖိုးများကို အလိုအလျောက် return ပြန်ပေးပါသည်။</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

func split(sum int) (x, y int) {
    x = sum * 4 / 9
    y = sum - x
    return // Naked return (x နှင့် y ကို ပြန်ပေးမည်)
}

func main() {
    fmt.Println(split(17)) // 7, 10
}</code></pre>
<h2 id="defer-statement">Defer Statement</h2>
<p><code>defer</code> statement သည် function တစ်ခု ပြီးဆုံးခါနီးအချိန် (return မပြန်ခင်) မှသာ လုပ်ဆောင်မည့် function call များကို သတ်မှတ်ရာတွင် အသုံးပြုသည်။ အဓိကအားဖြင့် resource များကို ရှင်းလင်းခြင်း (cleanup) အတွက် အလွန်အသုံးဝင်သည်။ ဥပမာ - file ပိတ်ခြင်း၊ database connection ပိတ်ခြင်း။</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

func main() {
    defer fmt.Println(&quot;world&quot;) // ဤလိုင်းသည် main function ပြီးခါနီးမှ အလုပ်လုပ်မည်

    fmt.Println(&quot;hello&quot;)
}
// Output:
// hello
// world</code></pre>
<p><code>defer</code> များစွာကို အသုံးပြုပါက <strong>LIFO (Last-In, First-Out)</strong> ပုံစံဖြင့် ပြောင်းပြန် အလုပ်လုပ်ပါသည်။</p>
<pre><code class="lang-go">func main() {
    fmt.Println(&quot;counting&quot;)

    for i := 0; i &lt; 3; i++ {
        defer fmt.Println(i)
    }

    fmt.Println(&quot;done&quot;)
}
// Output:
// counting
// done
// 2
// 1
// 0</code></pre>
<h2 id="variadic-functions">Variadic Functions</h2>
<p>Variadic function ဆိုသည်မှာ parameter အရေအတွက် မတူညီဘဲ လက်ခံနိုင်သော function ဖြစ်သည်။ Parameter ၏ type ရှေ့တွင် <code>...</code> ထည့်သွင်း၍ ကြေညာသည်။ Function အတွင်းတွင် ထို parameter ကို slice တစ်ခုအနေဖြင့် ရရှိမည်ဖြစ်သည်။</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

func sumAll(numbers ...int) int {
    total := 0
    // `numbers` သည် int slice (`[]int`) တစ်ခုဖြစ်သည်
    for _, num := range numbers {
        total += num
    }
    return total
}

func main() {
    fmt.Println(sumAll(1, 2, 3))       // 3 ခု pass လုပ်ခြင်း
    fmt.Println(sumAll(10, 20, 30, 40)) // 4 ခု pass လုပ်ခြင်း

    // Slice တစ်ခုကို pass လုပ်လိုပါက `...` ဖြင့် unpack လုပ်ရမည်
    nums := []int{5, 5, 5}
    fmt.Println(sumAll(nums...))
}</code></pre>
<h2 id="anonymous-functions-closures-">Anonymous Functions (Closures)</h2>
<p>Anonymous function ဆိုသည်မှာ အမည်မရှိသော function ဖြစ်သည်။ ၎င်းကို variable တစ်ခုတွင် ထည့်သွင်း၍သော်လည်းကောင်း၊ အခြား function တစ်ခု၏ argument အဖြစ် pass လုပ်၍သော်လည်းကောင်း အသုံးပြုနိုင်သည်။</p>
<p>Anonymous function သည် ၎င်း၏ ပတ်ဝန်းကျင် (surrounding scope) မှ variable များကို ရယူသုံးစွဲနိုင်သည့်အခါ ၎င်းကို <strong>closure</strong> ဟုခေါ်သည်။</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

func main() {
    // Anonymous function ကို variable တစ်ခုတွင် သိမ်းဆည်းခြင်း
    add := func(a, b int) int {
        return a + b
    }

    fmt.Println(&quot;Sum:&quot;, add(3, 4))

    // Closure ဥပမာ
    message := &quot;Hello&quot;

    // ဤ anonymous function သည် `message` variable ကို ၎င်း၏ scope အပြင်မှ ရယူသုံးစွဲသည်
    greet := func() {
        fmt.Println(message + &quot; from closure!&quot;)
    }

    greet()
}</code></pre>
<h3 id="closure-state-functions">Closure ၏ လက်တွေ့အသုံးဝင်ပုံ: State ကို မှတ်သားထားသော Functions</h3>
<p>Closure ၏ အစွမ်းထက်ဆုံး အသုံးဝင်မှုတစ်ခုမှာ &quot;factory&quot; function များ (function များကို return ပြန်ပေးသော function) တည်ဆောက်ခြင်းဖြစ်သည်။ Return ပြန်လိုက်သော function သည် ၎င်းကိုဖန်တီးခဲ့သည့် parent function ပြီးဆုံးသွားသည့်တိုင်အောင် parent function ၏ scope အတွင်းမှ variable များကို &quot;မှတ်သား&quot; ထားပြီး ပြန်လည်ရယူသုံးစွဲနိုင်စွမ်း ရှိသည်။ ဤနည်းလမ်းဖြင့် ကိုယ်ပိုင် private state များကို ထိန်းသိမ်းထားနိုင်သော function များ ဖန်တီးနိုင်ပါသည်။</p>
<p>ဥပမာကောင်းတစ်ခုမှာ တစ်ခုနှင့်တစ်ခုမတူညီသော ID များ ထုတ်ပေးသည့် generator တစ်ခု တည်ဆောက်ခြင်းဖြစ်သည်။</p>
<pre><code class="lang-mermaid">graph TD
    A[&quot;intSeq() called&quot;] --&gt; B[&quot;Create variable i = 0&quot;]
    B --&gt; C[&quot;Return a new function (closure)&quot;]

    subgraph &quot;Closure (nextInt)&quot;
        direction LR
        D[&quot;i is captured&lt;br/&gt;(current value: 0)&quot;]
        E[&quot;Function Body&lt;br/&gt;i++&lt;br/&gt;return i&quot;]
    end

    C --&gt; D
    C --&gt; E</code></pre>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

// intSeq function သည် အခြား function တစ်ခုကို return ပြန်ပေးသည်။
// return ပြန်လိုက်သော anonymous function သည် &#39;i&#39; variable ကို &quot;closes over&quot; လုပ်ထားသောကြောင့် closure ဖြစ်လာသည်။
func intSeq() func() int {
    i := 0
    return func() int {
        i++
        return i
    }
}

func main() {
    // nextInt သည် ယခုအခါ ကိုယ်ပိုင် &#39;i&#39; variable တစ်ခုကို ပိုင်ဆိုင်ထားသော function တစ်ခုဖြစ်သွားသည်။
    nextInt := intSeq()

    // nextInt ကို ခေါ်လိုက်တိုင်း ၎င်း၏ &#39;i&#39; တန်ဖိုးကို တိုးပြီး ပြန်ပေးမည်။
    fmt.Println(nextInt()) // Output: 1
    fmt.Println(nextInt()) // Output: 2
    fmt.Println(nextInt()) // Output: 3

    fmt.Println(&quot;---&quot;)

    // အသစ်တစ်ခု ထပ်မံဖန်တီးလိုပါက intSeq() ကို ထပ်ခေါ်ရမည်။
    // ၎င်းသည် လုံးဝသီးခြားဖြစ်သော &#39;i&#39; variable အသစ်တစ်ခုကို ရရှိမည်ဖြစ်သည်။
    newInts := intSeq()
    fmt.Println(newInts()) // Output: 1
}</code></pre>
<p>ဤဥပမာတွင် <code>intSeq()</code> function ကို ခေါ်လိုက်သောအခါ <code>i</code> ဟူသော variable တစ်ခုကို 0 ဖြင့် စတင်ပြီး function တစ်ခုကို return ပြန်ပေးပါသည်။ <code>nextInt</code> သည် ထို return ပြန်လာသော function ဖြစ်ပြီး ၎င်းသည် <code>i</code> ကို မှတ်သားထားသည်။ <code>nextInt()</code> ကို ခေါ်လိုက်တိုင်း မှတ်သားထားသော <code>i</code> ၏ တန်ဖိုးကို တိုးခြင်း၊ ပြန်ပေးခြင်းတို့ကို လုပ်ဆောင်သောကြောင့် state ကို ဆက်တိုက် ထိန်းသိမ်းထားနိုင်ခြင်း ဖြစ်သည်။</p>
<h1 id="-pointers">အခန်း ၈: Pointers</h1>
<p>ယခုအခန်းတွင် Go ၏ အရေးကြီးသော concept တစ်ခုဖြစ်သည့် Pointers အကြောင်းကို လေ့လာသွားပါမည်။ Pointer သည် memory address များကို တိုက်ရိုက်ကိုင်တွယ်ရန် အသုံးပြုပြီး၊ function များသို့ data များ pass လုပ်ရာတွင် ပိုမိုထိရောက်စေရန်နှင့် မူလ data များကို ပြောင်းလဲနိုင်ရန်အတွက် အဓိက အသုံးပြုပါသည်။</p>
<h2 id="pointer-memory-address-">Pointer ဆိုတာဘာလဲ။ (Memory Address)</h2>
<p>Program တစ်ခုတွင် variable တိုင်းသည် ကွန်ပျူတာ၏ memory တွင် နေရာတစ်ခုယူ၍ တန်ဖိုးများကို သိမ်းဆည်းထားပါသည်။ ထို memory နေရာတိုင်းတွင် လိပ်စာ (address) တစ်ခုစီ ရှိပါသည်။</p>
<p><strong>Pointer</strong> ဆိုသည်မှာ အခြား variable တစ်ခု၏ <strong>memory address</strong> ကို တန်ဖိုးအနေဖြင့် သိမ်းဆည်းထားသော variable တစ်မျိုးဖြစ်သည်။</p>
<p>ဥပမာ၊ <code>name</code> ဆိုသော variable တွင် <code>&quot;Go Language&quot;</code> ဟူသော တန်ဖိုးရှိပြီး ၎င်းသည် memory address <code>0x1040a124</code> တွင် ရှိနေသည်ဆိုပါစို့။ <code>p</code> ဟူသော pointer တစ်ခုသည် <code>name</code> ၏ တန်ဖိုး <code>&quot;Go Language&quot;</code> ကို တိုက်ရိုက်သိမ်းဆည်းခြင်းမဟုတ်ဘဲ၊ <code>name</code> ၏ memory address ဖြစ်သော <code>0x1040a124</code> ကို သိမ်းဆည်းထားပါသည်။</p>
<p>ဤဆက်စပ်မှုကို အောက်ပါပုံဖြင့် ပိုမိုရှင်းလင်းစွာ မြင်နိုင်ပါသည်။</p>
<pre><code class="lang-mermaid">graph LR
    subgraph &quot;Memory Space&quot;
        Address1[&quot;Address: 0x1040a124&lt;br/&gt;Variable: name&lt;br/&gt;Value: &#39;Go Language&#39;&quot;]
    end

    subgraph &quot;Pointer Variable&quot;
        PointerP[&quot;Variable: p&lt;br/&gt;Type: *string&lt;br/&gt;Value: 0x1040a124&quot;]
    end

    PointerP -- &quot;ညွှန်ပြနေသည် (points to)&quot; --&gt; Address1</code></pre>
<p>Pointer type ကို ကြေညာရာတွင် ၎င်းညွှန်ပြမည့် variable ၏ type ရှေ့တွင် <code>*</code> သင်္ကေတကို ထည့်သွင်းရေးသားရသည်။ ဥပမာ၊ <code>int</code> variable တစ်ခုကို ညွှန်ပြမည့် pointer ၏ type မှာ <code>*int</code> ဖြစ်သည်။</p>
<h2 id="-address-of-dereference-operators"><code>&amp;</code> (address of) နှင့် <code>*</code> (dereference) Operators</h2>
<p>Pointers များနှင့် အလုပ်လုပ်ရာတွင် အဓိကကျသော operator နှစ်ခုမှာ <code>&amp;</code> နှင့် <code>*</code> ဖြစ်သည်။</p>
<ul>
<li><strong><code>&amp;</code> (Address of) Operator:</strong> Variable တစ်ခု၏ ရှေ့တွင် <code>&amp;</code> ကို ထားရှိပါက ၎င်း variable ၏ memory address ကို ရရှိမည်ဖြစ်သည်။</li>
<li><strong><code>*</code> (Dereferencing) Operator:</strong> Pointer variable တစ်ခု၏ ရှေ့တွင် <code>*</code> ကို ထားရှိပါက ၎င်း pointer ညွှန်ပြနေသော memory address ရှိ <strong>တန်ဖိုး (value)</strong> ကို ရရှိမည်ဖြစ်သည်။ ၎င်းကို &quot;dereferencing&quot; ဟုခေါ်သည်။</li>
</ul>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

func main() {
    // 1. &#39;name&#39; variable ကို string တန်ဖိုးတစ်ခုဖြင့် ကြေညာခြင်း
    name := &quot;Go Language&quot;
    fmt.Println(&quot;Original value of name:&quot;, name)

    // 2. &#39;name&#39; variable ၏ memory address ကို ရယူပြီး &#39;p&#39; pointer ထဲသို့ ထည့်ခြင်း
    var p *string = &amp;name

    fmt.Println(&quot;Memory address of name (&amp;name):&quot;, &amp;name)
    fmt.Println(&quot;Value of pointer p (address):&quot;, p)

    // 3. Pointer &#39;p&#39; ကို dereference လုပ်ပြီး ၎င်းညွှန်ပြနေသော တန်ဖိုးကို ရယူခြင်း
    fmt.Println(&quot;Value at address p (*p):&quot;, *p)

    // 4. Pointer မှတစ်ဆင့် မူလ variable ၏ တန်ဖိုးကို ပြောင်းလဲခြင်း
    *p = &quot;Golang&quot;
    fmt.Println(&quot;Value of name after modification via pointer:&quot;, name)
}</code></pre>
<h2 id="pointer-">Pointer ကို ဘာကြောင့် သုံးသင့်သလဲ။</h2>
<p>Pointer ကို အသုံးပြုရခြင်း၏ အဓိက အကြောင်းရင်းနှစ်ခုမှာ-</p>
<p><strong>1. Function များအတွင်းမှ မူလ Variable ၏ တန်ဖိုးကို ပြောင်းလဲရန်</strong></p>
<p>Go တွင် function တစ်ခုသို့ variable တစ်ခုကို pass လုပ်သည့်အခါ ၎င်း variable ၏ copy တစ်ခုကိုသာ pass လုပ်ခြင်းဖြစ်သည် (pass-by-value)။ ထို့ကြောင့် function အတွင်းတွင် ထို variable ကို ပြောင်းလဲလိုက်သော်လည်း မူလ variable ပြောင်းလဲသွားမည်မဟုတ်ပါ။</p>
<p>မူလ variable ကို ပြောင်းလဲလိုပါက ၎င်း variable ၏ pointer ကို function သို့ pass လုပ်ရမည်။</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

// value ကို pass လုပ်ခြင်း (copy တစ်ခုသာ ရောက်ရှိသည်)
func changeValue(val int) {
    val = 100
}

// pointer ကို pass လုပ်ခြင်း (memory address ကို ရောက်ရှိသည်)
func changeValueByPointer(ptr *int) {
    *ptr = 100
}

func main() {
    x := 10
    changeValue(x)
    fmt.Println(&quot;Value of x after changeValue:&quot;, x) // 10 (မပြောင်းလဲ)

    y := 10
    changeValueByPointer(&amp;y)
    fmt.Println(&quot;Value of y after changeValueByPointer:&quot;, y) // 100 (ပြောင်းလဲသွားသည်)
}</code></pre>
<p><strong>2. Performance နှင့် Efficiency</strong></p>
<p>Struct ကဲ့သို့သော data structure ကြီးများကို function သို့ pass လုပ်သည့်အခါ value ဖြင့် pass လုပ်ပါက data အားလုံးကို copy ကူးရသောကြောင့် memory နှင့် အချိန် ပိုမိုကုန်ကျစေသည်။ Pointer ဖြင့် pass လုပ်ပါက memory address (များသောအားဖြင့် 8 bytes) ကိုသာ copy ကူးရသောကြောင့် ပိုမိုမြန်ဆန်ပြီး ထိရောက်မှုရှိပါသည်။ ဤသည်မှာ အခန်း ၆ တွင် လေ့လာခဲ့သော pointer receivers များ၏ အလုပ်လုပ်ပုံနှင့် တူညီပါသည်။</p>
<p><strong>Pointer ၏ Zero Value</strong></p>
<p>Pointer တစ်ခု၏ zero value (တန်ဖိုးမထည့်သွင်းရသေးခင် default တန်ဖိုး) မှာ <code>nil</code> ဖြစ်သည်။ <code>nil</code> pointer ဆိုသည်မှာ မည်သည့် memory address ကိုမှ ညွှန်ပြမထားသော pointer ဖြစ်သည်။</p>
<h2 id="the-new-function">The <code>new()</code> Function</h2>
<p>Go တွင် pointer အသစ်တစ်ခု ဖန်တီးရန် <code>new()</code> function ကိုလည်း အသုံးပြုနိုင်သည်။ <code>new(Type)</code> သည် Type ထဲရှိ zero value (ဥပမာ <code>int</code> ဆိုလျှင် <code>0</code>, <code>string</code> ဆိုလျှင် <code>&quot;&quot;</code>) အတွက် memory နေရာချထားပေးပြီး၊ ထိုနေရာ၏ <strong>memory address (pointer)</strong> ကို ပြန်ပေးသည်။</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

func main() {
    // new() ကို အသုံးပြု၍ int pointer တစ်ခု ဖန်တီးခြင်း
    // p သည် *int type ဖြစ်ပြီး၊ ၎င်းညွှန်ပြနေသော တန်ဖိုးမှာ 0 ဖြစ်သည်
    p := new(int)

    fmt.Println(&quot;Value of p (address):&quot;, p)
    fmt.Println(&quot;Value at *p (zero value):&quot;, *p) // Output: 0

    // တန်ဖိုးပြောင်းလဲခြင်း
    *p = 100
    fmt.Println(&quot;New value at *p:&quot;, *p) // Output: 100
}</code></pre>
<h3 id="-new-vs-make-"><code>new()</code> vs <code>make()</code> ကွာခြားချက်</h3>
<ul>
<li><strong><code>new(T)</code></strong>: <code>T</code> type အတွက် memory နေရာချထားပြီး၊ zero value <strong>(*T) pointer</strong> ကို ပြန်ပေးသည်။ (Variable အသစ်/Pointer ဖန်တီးရန် သုံးသည်)</li>
<li><strong><code>make(T)</code></strong>: Slices, Maps, Channels ကဲ့သို့သော Reference type များအတွက်သာ သုံးပြီး၊ initialized လုပ်ထားသော <strong>T value (Non-pointer)</strong> ကို ပြန်ပေးသည်။ (အခန်း ၅ တွင် ပြန်ကြည့်နိုင်ပါသည်)</li>
</ul>
<h3 id="nil-pointer-dereference-">Nil Pointer Dereference (အမှားများနှင့် ကာကွယ်ခြင်း)</h3>
<p><code>nil</code> pointer ဆိုသည်မှာ မည်သည့် memory address ကိုမှ ညွှန်ပြမထားသော pointer ဖြစ်သည်။</p>
<p><code>nil</code> pointer တစ်ခုကို dereference လုပ်ရန် ကြိုးစားခြင်း (ဥပမာ <code>*p</code> ဟုရေးခြင်း) သည် Go တွင် အဖြစ်များသော runtime error တစ်ခုဖြစ်ပြီး၊ ၎င်းသည် program ကိုချက်ချင်းရပ်တန့်သွားစေသော <strong>panic</strong> ကို ဖြစ်စေပါသည်။</p>
<p><strong>အဘယ်ကြောင့် panic ဖြစ်ရသနည်း။</strong>
<code>nil</code> pointer သည် မည်သည့် memory location ကိုမှ ညွှန်ပြမထားသောကြောင့် ၎င်းညွှန်ပြရာနေရာရှိ တန်ဖိုးကို ရယူရန် ကြိုးစားခြင်းသည် အဓိပ္ပာယ်မရှိသော လုပ်ဆောင်ချက်ဖြစ်သောကြောင့် program က <code>invalid memory address or nil pointer dereference</code> ဟူသော panic message ဖြင့် crash ဖြစ်သွားပါသည်။</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

func main() {
    var p *int // p သည် nil ဖြစ်နေသည်

    // nil pointer ကို dereference မလုပ်မီ အမြဲတမ်းစစ်ဆေးသင့်သည်
    if p != nil {
        fmt.Println(&quot;Value of p:&quot;, *p)
    } else {
        fmt.Println(&quot;p is a nil pointer, cannot dereference.&quot;)
    }

    // အောက်ပါ code line သည် panic ကို ဖြစ်စေပါမည်။ uncomment လုပ်ပြီး run ကြည့်နိုင်ပါသည်။
    // fmt.Println(*p) 
    // panic: runtime error: invalid memory address or nil pointer dereference
}</code></pre>
<p><strong>အကောင်းဆုံး လိုက်နာရန် (Best Practice):</strong> Pointer တစ်ခုကို dereference မလုပ်မီ၊ ၎င်းသည် <code>nil</code> မဟုတ်ကြောင်း အမြဲတမ်း <code>if p != nil</code> ဖြင့် စစ်ဆေးခြင်းသည် program crash ဖြစ်ခြင်းမှ ကာကွယ်ပေးနိုင်သော အလေ့အကျင့်ကောင်းတစ်ခု ဖြစ်သည်။</p>
<h1 id="-interfaces">အခန်း ၉: Interfaces</h1>
<p>ယခုအခန်းတွင် Go ၏ အလွန်အရေးပါပြီး အစွမ်းထက်သော feature တစ်ခုဖြစ်သည့် <code>interface</code> အကြောင်းကို လေ့လာသွားပါမည်။ Interface သည် code များကို ပိုမို flexible, reusable, နှင့် decoupled ဖြစ်စေရန်အတွက် အဓိကကျသော concept တစ်ခုဖြစ်သည်။</p>
<h2 id="interface-">Interface ဆိုတာဘာလဲ။</h2>
<p>Go တွင် Interface ဆိုသည်မှာ method signatures (method အမည်၊ parameters, return types) များ၏ စုစည်းမှုတစ်ခုကို သတ်မှတ်ထားသော abstract type တစ်ခုဖြစ်သည်။ Interface သည် &quot;ဘာတွေလုပ်ဆောင်နိုင်ရမည်&quot; (<code>what it can do</code>) ဆိုသည့် <strong>behavior (အပြုအမူ)</strong> ကိုသာ သတ်မှတ်ပြီး၊ &quot;ဘယ်လိုလုပ်ဆောင်ရမည်&quot; (<code>how it does it</code>) ဆိုသည့် implementation ကို မသတ်မှတ်ပါ။</p>
<p>Struct တစ်ခု သို့မဟုတ် အခြား type တစ်ခုက interface တွင် သတ်မှတ်ထားသော method များအားလုံးကို implement လုပ်ထားပါက၊ ထို type သည် ထို interface ကို &quot;satisfy&quot; လုပ်သည် (သို့မဟုတ် implement လုပ်သည်) ဟုခေါ်ဆိုနိုင်ပါသည်။ အခြား language များကဲ့သို့ <code>implements</code> keyword ကို တိတိကျကျ ရေးသားရန်မလိုဘဲ Go compiler က အလိုအလျောက် သိရှိပါသည်။</p>
<pre><code class="lang-go">package main

import (
    &quot;fmt&quot;
    &quot;math&quot;
)

// Shape interface သည် Area()  method တစ်ခုရှိရမည်ဟု သတ်မှတ်သည်
type Shape interface {
    Area() float64
}

// Rectangle struct
type Rectangle struct {
    Width  float64
    Height float64
}

// Rectangle အတွက် Area() method ကို implement လုပ်ခြင်း
// ဤ method ရှိသောကြောင့် Rectangle သည် Shape interface ကို satisfy လုပ်သည်
func (r Rectangle) Area() float64 {
    return r.Width * r.Height
}

// Circle struct
type Circle struct {
    Radius float64
}

// Circle အတွက် Area() method ကို implement လုပ်ခြင်း
// ဤ method ရှိသောကြောင့် Circle သည် Shape interface ကို satisfy လုပ်သည်
func (c Circle) Area() float64 {
    return math.Pi * c.Radius * c.Radius
}

func main() {
    rect := Rectangle{Width: 10, Height: 5}
    circ := Circle{Radius: 7}

    // rect နှင့် circ တို့သည် Shape interface ကို implement လုပ်ထားသည်
    fmt.Printf(&quot;Rectangle Area: %f\n&quot;, rect.Area())
    fmt.Printf(&quot;Circle Area: %f\n&quot;, circ.Area())
}</code></pre>
<h2 id="duck-typing-if-it-walks-like-a-duck-">Duck Typing (&quot;If it walks like a duck...&quot;)</h2>
<p>Go ၏ Interface များကို <strong>Duck Typing</strong> concept ဖြင့် မကြာခဏ တင်စားလေ့ရှိသည်။ Duck Typing ၏ ဆိုလိုရင်းမှာ -</p>
<blockquote>
<p>&quot;If it looks like a duck, swims like a duck, and quacks like a duck, then it probably is a duck.&quot;
(&quot;ဘဲတစ်ကောင်လို ရုပ်ဆင်းသဏ္ဍာန်ရှိပြီး၊ ဘဲတစ်ကောင်လို ရေကူးနိုင်ကာ၊ ဘဲတစ်ကောင်လို အော်မြည်နိုင်လျှင်၊ ၎င်းသည် ဘဲတစ်ကောင် ဖြစ်လောက်သည်။&quot;)</p>
</blockquote>
<p>Go တွင်လည်း ထိုနည်းလည်းကောင်းပင်ဖြစ်သည်။ Type တစ်ခုသည် Interface တစ်ခုက သတ်မှတ်ထားသော method များကို ပိုင်ဆိုင်ထားလျှင်၊ ထို Type သည် ထို Interface ပင်ဖြစ်သည်။ ၎င်းသည် <strong>Explicit Declaration</strong> (ဥပမာ Java တွင် <code>implements</code> ဟု ကြေညာခြင်း) မလိုအပ်ဘဲ <strong>Implicit Satisfaction</strong> ဖြစ်သည်။</p>
<p>ဤအချက်က Go ၏ code များကို အလွန် flexible ဖြစ်စေသည်။ Library အသစ်တစ်ခု ရေးသားရာတွင် အသုံးပြုမည့် Type များကို ကြိုတင်သိရှိရန် မလိုအပ်ဘဲ၊ လိုအပ်သော method များကိုသာ Interface အဖြစ် သတ်မှတ်ထားခဲ့လျှင်၊ နောင်တွင် မည်သူမဆို ထို method များပါဝင်သော Type အသစ်များ ဖန်တီး၍ တွဲဖက်အသုံးပြုနိုင်ပါသည်။</p>
<h2 id="go-interfaces-vs-oop-interfaces-e-g-java-">Go Interfaces vs OOP Interfaces (e.g., Java)</h2>
<p>Object-Oriented Programming (OOP) ဘာသာစကားများ (ဥပမာ Java, C#) နှင့် Go ၏ Interface ကွာခြားချက်များကို နှိုင်းယှဉ်ကြည့်ကြပါစို့။</p>
<table>
<thead>
<tr>
<th style="text-align:left">Feature</th>
<th style="text-align:left">Java (Classic OOP)</th>
<th style="text-align:left">Go</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>Implementation</strong></td>
<td style="text-align:left"><strong>Explicit</strong> (တိကျစွာ ကြေညာရသည်)</td>
<td style="text-align:left"><strong>Implicit</strong> (အလိုအလျောက် သိရှိသည်)</td>
</tr>
<tr>
<td style="text-align:left"><strong>Keyword</strong></td>
<td style="text-align:left"><code>class Dog implements Animal</code></td>
<td style="text-align:left">မလိုပါ။ Method စုံလျှင် ပြီးပြီ။</td>
</tr>
<tr>
<td style="text-align:left"><strong>Dependency</strong></td>
<td style="text-align:left">Concrete type သည် Interface ကို သိရှိရန် လိုအပ်သည်။</td>
<td style="text-align:left">Concrete type သည် Interface ကို သိရန် မလိုအပ်ပါ။</td>
</tr>
<tr>
<td style="text-align:left"><strong>Flexibility</strong></td>
<td style="text-align:left">နည်းသည်။ Interface ပြောင်းလျှင် Class ပါ လိုက်ပြင်ရသည်။</td>
<td style="text-align:left">များသည်။ Package များအကြား coupling နည်းစေသည်။</td>
</tr>
</tbody>
</table>
<p><strong>Java Example:</strong></p>
<pre><code class="lang-java">// Java
interface Animal {
    void speak();
}

// &#39;implements Animal&#39; ဟု မပါလျှင် Animal မဟုတ်ပါ
class Dog implements Animal {
    public void speak() {
        System.out.println(&quot;Woof!&quot;);
    }
}</code></pre>
<p><strong>Go Example:</strong></p>
<pre><code class="lang-go">// Go
type Animal interface {
    Speak()
}

// ဘာမှ ကြေညာစရာ မလိုပါ
type Dog struct {}

func (d Dog) Speak() {
    fmt.Println(&quot;Woof!&quot;)
}
// Dog သည် Speak() ရှိသောကြောင့် အလိုအလျောက် Animal ဖြစ်သွားသည်</code></pre>
<h2 id="polymorphism-interfaces-">Polymorphism ကို Interfaces ဖြင့် အကောင်အထည်ဖော်ခြင်း</h2>
<p>Interface ၏ အဓိကအသုံးဝင်မှုမှာ polymorphism ကို အကောင်အထည်ဖော်နိုင်ခြင်းဖြစ်သည်။ Polymorphism ဆိုသည်မှာ code တစ်ခုတည်းက မတူညီသော data types များစွာနှင့် အလုပ်လုပ်နိုင်စွမ်းရှိခြင်း ဖြစ်သည်။</p>
<p>Function တစ်ခု၏ parameter ကို interface type ဖြင့် သတ်မှတ်ထားပါက၊ ထို interface ကို satisfy လုပ်သော မည်သည့် concrete type (struct) ကိုမဆို ထို function သို့ pass လုပ်နိုင်ပါသည်။</p>
<pre><code class="lang-mermaid">graph TD
    subgraph &quot;Concrete Types (Structs)&quot;
        Rectangle[&quot;Rectangle Struct&lt;br/&gt;- Area() method&quot;]
        Circle[&quot;Circle Struct&lt;br/&gt;- Area() method&quot;]
    end

    subgraph &quot;Abstract Type (Interface)&quot;
        Shape[&quot;Shape Interface&lt;br/&gt;- Area() float64&quot;]
    end

    subgraph &quot;Function using Interface&quot;
        PrintArea[&quot;printArea(s Shape)&quot;]
    end

    Rectangle -- &quot;implicitly implements&quot; --&gt; Shape
    Circle -- &quot;implicitly implements&quot; --&gt; Shape

    PrintArea -- &quot;can accept&quot; --&gt; Rectangle
    PrintArea -- &quot;can accept&quot; --&gt; Circle</code></pre>
<p>အောက်ပါ code တွင် <code>printArea</code> function သည် <code>Shape</code> interface ကို parameter အဖြစ် လက်ခံသည်။ ထို့ကြောင့် <code>Rectangle</code> နှင့် <code>Circle</code> နှစ်မျိုးလုံးကို ၎င်းထံသို့ pass လုပ်နိုင်ပါသည်။</p>
<pre><code class="lang-go">// ... (အပေါ်မှ struct နှင့် method definitions များ ဆက်လက်ပါဝင်သည်)

// ဤ function သည် Shape interface ကို satisfy လုပ်သော မည်သည့် type ကိုမဆို လက်ခံနိုင်သည်
func printArea(s Shape) {
    fmt.Printf(&quot;The area of the shape is %f\n&quot;, s.Area())
}

func main() {
    rect := Rectangle{Width: 10, Height: 5}
    circ := Circle{Radius: 7}

    printArea(rect)
    printArea(circ)
}</code></pre>
<h2 id="empty-interface-interface-">Empty Interface (<code>interface{}</code>)</h2>
<p>Empty interface (<code>interface{}</code>) ဆိုသည်မှာ method တစ်ခုမှ မပါဝင်သော interface ဖြစ်သည်။ ၎င်းတွင် method မည်မျှမှ မသတ်မှတ်ထားသောကြောင့် Go ရှိ <strong>မည်သည့် data type မဆို</strong> empty interface ကို အလိုအလျောက် satisfy လုပ်ပါသည်။</p>
<p>၎င်းကို data type ကြိုတင်မသိနိုင်သော တန်ဖိုးများကို ကိုင်တွယ်ရန် အသုံးပြုသည်။ ဥပမာ၊ <code>int</code>, <code>string</code>, <code>bool</code>, <code>struct</code> စသည်ဖြင့် မည်သည့် type မဆို ဖြစ်နိုင်သည်။</p>
<h3 id="type-assertion">Type Assertion</h3>
<p>Empty interface ထဲသို့ ထည့်လိုက်သော တန်ဖိုးသည် ၎င်း၏ မူလ type အချက်အလက် ပျောက်ဆုံးသွားသည်။ ထိုတန်ဖိုးကို ပြန်လည်အသုံးပြုရန်အတွက် ၎င်း၏ မူလ concrete type သို့ ပြန်လည်ပြောင်းလဲရန် လိုအပ်သည်။ ဤသို့ ပြောင်းလဲခြင်းကို <strong>type assertion</strong> ဟုခေါ်သည်။</p>
<p>Type assertion ကို <code>i.(T)</code> syntax ဖြင့် ပြုလုပ်သည်။ <code>i</code> သည် interface variable ဖြစ်ပြီး <code>T</code> သည် ပြောင်းလဲလိုသော type ဖြစ်သည်။</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

func describe(i interface{}) {
    fmt.Printf(&quot;Value: %v, Type: %T\n&quot;, i, i)

    // Safe type assertion
    // `s` တွင် တန်ဖိုးကို ရရှိပြီး `ok` တွင် ပြောင်းလဲမှု အောင်မြင်/မအောင်မြင် (true/false) ကို ရရှိမည်
    s, ok := i.(string)
    if ok {
        fmt.Println(&quot;This is a string with length&quot;, len(s))
    }

    // `switch` ဖြင့် type assertion ပြုလုပ်ခြင်းက ပိုမိုရှင်းလင်းသည်
    switch v := i.(type) {
    case int:
        fmt.Println(&quot;This is an integer, and its value is&quot;, v)
    case string:
        fmt.Println(&quot;This is a string, and its value is&quot;, v)
    default:
        fmt.Println(&quot;Unknown type!&quot;)
    }
    fmt.Println(&quot;---&quot;)
}

func main() {
    describe(42)
    describe(&quot;hello&quot;)
    describe(true)
}</code></pre>
<h2 id="interface-embedding-interface-">Interface Embedding (Interface များကို ပေါင်းစပ်ခြင်း)</h2>
<p>Go တွင် struct များကို embed လုပ်သကဲ့သို့ပင်၊ <strong>Interface</strong> များကိုလည်း အခြား Interface တစ်ခုအတွင်းသို့ embed လုပ်၍ ပေါင်းစပ်နိုင်ပါသည်။ ၎င်းသည် ကြီးမားသော Interface များကို သေးငယ်သော Interface များမှတစ်ဆင့် တည်ဆောက်ခြင်း (Composition) ကို အားပေးသည်။</p>
<p>Go ၏ standard library ဖြစ်သော <code>io</code> package မှ နာမည်ကြီးဥပမာတစ်ခုကို လေ့လာကြည့်ကြပါစို့။</p>
<pre><code class="lang-go">type Reader interface {
    Read(p []byte) (n int, err error)
}

type Writer interface {
    Write(p []byte) (n int, err error)
}

// ReadWriter interface သည် Reader နှင့် Writer ကို ပေါင်းစပ်ထားခြင်းဖြစ်သည်
// ၎င်း interface ကို satisfy လုပ်ရန် Read() ရော Write() ပါ ရှိရန်လိုအပ်သည်
type ReadWriter interface {
    Reader // Embedded interface
    Writer // Embedded interface
}</code></pre>
<h2 id="interface-database-drivers">Interface ၏ လက်တွေ့အသုံးဝင်ပုံ: Database Drivers</h2>
<p>Interface ၏ အစွမ်းထက်ပုံကို အကောင်းဆုံးမြင်နိုင်သော လက်တွေ့ဥပမာမှာ Go ၏ standard <code>database/sql</code> package ဖြစ်သည်။</p>
<p><strong>ပြဿနာ:</strong> ကျွန်ုပ်တို့၏ application သည် MySQL, PostgreSQL, SQLite ကဲ့သို့သော မတူညီသည့် database များစွာနှင့် ချိတ်ဆက်ရန် လိုအပ်နိုင်သည်။ Database တစ်ခုချင်းစီအတွက် code များကို သီးခြားစီ ရေးသားမည်ဆိုပါက code များ ထပ်တူညီပြီး ပြုပြင်ထိန်းသိမ်းရန် အလွန်ခက်ခဲသွားပါမည်။</p>
<p><strong>Interface ဖြင့် ဖြေရှင်းခြင်း:</strong>
<code>database/sql</code> package သည် database နှင့် ဆက်သွယ်ရန်အတွက် <code>sql.Driver</code>, <code>sql.Conn</code> ကဲ့သို့သော interface များကို <strong>သတ်မှတ်ပေးထားသည်</strong>။ သို့သော် ၎င်းသည် MySQL သို့မဟုတ် PostgreSQL နှင့် မည်သို့ချိတ်ဆက်ရမည်ကို <strong>implement မလုပ်ပါ</strong>။</p>
<p>ထိုအစား၊ third-party driver developer များ (ဥပမာ- <code>go-sql-driver/mysql</code>) က ထို <code>sql.Driver</code> interface ကို သူတို့၏ database အတွက် implement လုပ်ထားသော concrete type များကို ရေးသားပေးပါသည်။</p>
<p>ကျွန်ုပ်တို့၏ application code သည် <code>database/sql</code> package ၏ functions (ဥပမာ- <code>sql.Open()</code>, <code>db.Query()</code>) များကိုသာ ခေါ်ယူသုံးစွဲပြီး၊ နောက်ကွယ်တွင် <code>database/sql</code> package က သက်ဆိုင်ရာ driver ၏ implementation ကို interface မှတစ်ဆင့် ခေါ်ယူသုံးစွဲပေးပါသည်။</p>
<pre><code class="lang-mermaid">graph TD
    subgraph &quot;Your Application Code&quot;
        App[&quot;app.go&lt;br/&gt;db.Query(&#39;SELECT...&#39;)&quot;]
    end

    subgraph &quot;Go Standard Library&quot;
        StdSQL[&quot;database/sql package&lt;br/&gt;(Defines Driver interface)&quot;]
    end

    subgraph &quot;Third-Party Drivers (Concrete Implementations)&quot;
        MySQLDriver[&quot;MySQL Driver&lt;br/&gt;(implements Driver interface)&quot;]
        PGDriver[&quot;PostgreSQL Driver&lt;br/&gt;(implements Driver interface)&quot;]
    end

    App -- &quot;uses&quot; --&gt; StdSQL
    MySQLDriver -- &quot;satisfies&quot; --&gt; StdSQL
    PGDriver -- &quot;satisfies&quot; --&gt; StdSQL</code></pre>
<p><strong>အကျိုးကျေးဇူး:</strong> ကျွန်ုပ်တို့၏ application code သည် database အမျိုးအစားကို တိုက်ရိုက်သိရန်မလိုဘဲ (database-agnostic)၊ <code>database/sql</code> interface ကိုသာ သိရန်လိုအပ်သည်။ ထို့ကြောင့် နောင်တွင် MySQL မှ PostgreSQL သို့ ပြောင်းလဲလိုပါက driver import နှင့် connection string ကိုသာ ပြောင်းလဲရန်လိုအပ်ပြီး application ၏ core logic (e.g., <code>db.Query(...)</code>) ကို လုံးဝပြောင်းလဲရန် မလိုအပ်တော့ပါ။</p>
<p><strong>ဥပမာ Code:</strong></p>
<pre><code class="lang-go">package main

import (
    &quot;database/sql&quot;
    &quot;fmt&quot;

    // Driver များကို ၎င်းတို့၏ side effect (registering) အတွက် import လုပ်သည်
    // `_` ကို အသုံးပြုခြင်းမှာ driver variable များကို တိုက်ရိုက်အသုံးမပြုသောကြောင့်ဖြစ်သည်
    _ &quot;github.com/go-sql-driver/mysql&quot;
    _ &quot;github.com/lib/pq&quot;
)

// getUsers function သည် database-agnostic ဖြစ်သည်
// ၎င်းသည် *sql.DB ကိုသာ သိပြီး MySQL လား PostgreSQL လား မသိပါ
func getUsers(db *sql.DB) {
    rows, err := db.Query(&quot;SELECT id, name FROM users LIMIT 2&quot;)
    if err != nil {
        panic(err)
    }
    defer rows.Close()
    fmt.Println(&quot;Successfully queried users.&quot;)
}

func main() {
    // ဤသည်မှာ conceptual example ဖြစ်သည်
    // MySQL database နှင့် ချိတ်ဆက်ခြင်း
    mysqlDB, err := sql.Open(&quot;mysql&quot;, &quot;user:password@tcp(127.0.0.1:3306)/hello&quot;)
    if err == nil {
        getUsers(mysqlDB)
        mysqlDB.Close()
    }

    // PostgreSQL database နှင့် ချိတ်ဆက်ခြင်း
    postgresDB, err := sql.Open(&quot;postgres&quot;, &quot;user=pqgotest dbname=pqgotest sslmode=disable&quot;)
    if err == nil {
        getUsers(postgresDB) // တူညီသော function ကို ပြန်လည်အသုံးပြုနိုင်သည်
        postgresDB.Close()
    }
}</code></pre>
<h2 id="design-pattern-strategy-pattern">Design Pattern: Strategy Pattern</h2>
<p>Interface များကို အသုံးပြု၍ <strong>Strategy Pattern</strong> ကို အလွယ်တကူ တည်ဆောက်နိုင်သည်။ Strategy Pattern ဆိုသည်မှာ algorithm သို့မဟုတ် လုပ်ဆောင်ပုံလုပ်ဆောင်နည်း တစ်ခုကို runtime တွင် လိုအပ်သလို ပြောင်းလဲအသုံးပြုနိုင်သော နည်းလမ်းဖြစ်သည်။</p>
<p>ဥပမာ - Online Shopping တစ်ခုတွင် ငွေပေးချေမှုပုံစံ (Payment Method) အမျိုးမျိုးရှိနိုင်သည်။ KBZPay, WaveMoney, သို့မဟုတ် Credit Card စသည်ဖြင့်။</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

// 1. Strategy Interface သတ်မှတ်ခြင်း
type PaymentStrategy interface {
    Pay(amount float64)
}

// 2. Concrete Strategies (နည်းလမ်းအမျိုးမျိုး)
type KBZPay struct{}

func (k KBZPay) Pay(amount float64) {
    fmt.Printf(&quot;Paid %.2f using KBZPay\n&quot;, amount)
}

type WaveMoney struct{}

func (w WaveMoney) Pay(amount float64) {
    fmt.Printf(&quot;Paid %.2f using WaveMoney\n&quot;, amount)
}

type CreditCard struct {
    CardNumber string
}

func (c CreditCard) Pay(amount float64) {
    fmt.Printf(&quot;Paid %.2f using Credit Card (%s)\n&quot;, amount, c.CardNumber)
}

// 3. Context (အသုံးပြုသူ)
type ShoppingCart struct {
    amount  float64
    payment PaymentStrategy // Interface ကို field အဖြစ်ထားသည်
}

func (c *ShoppingCart) Checkout() {
    c.payment.Pay(c.amount)
}

func main() {
    // KBZPay ဖြင့် ပေးချေခြင်း
    cart1 := ShoppingCart{amount: 100.0, payment: KBZPay{}}
    cart1.Checkout()

    // WaveMoney သို့ ပြောင်းလဲခြင်း (Strategy ပြောင်းခြင်း)
    cart1.payment = WaveMoney{}
    cart1.Checkout()

    // Credit Card ဖြင့် ပေးချေခြင်း
    cart2 := ShoppingCart{amount: 5000.0, payment: CreditCard{CardNumber: &quot;1234-5678&quot;}}
    cart2.Checkout()
}</code></pre>
<p>ဤနည်းအားဖြင့် <code>ShoppingCart</code> struct သည် မည်သည့် payment method ကို သုံးထားသည်ကို အတိအကျ သိစရာမလိုဘဲ၊ <code>Pay()</code> method ပါဝင်သော မည်သည့် strategy ကိုမဆို လက်ခံအလုပ်လုပ်နိုင်ပါသည်။</p>
<h1 id="-packages-modules">အခန်း ၁၀: Packages နှင့် Modules</h1>
<p>ယခုအခန်းတွင် Go project များကို စနစ်တကျ တည်ဆောက်ရန်နှင့် code များကို ပြန်လည်အသုံးပြုရန်အတွက် အခြေခံကျသော Packages နှင့် Modules များအကြောင်းကို လေ့လာသွားပါမည်။</p>
<h2 id="package-">Package ဆိုတာဘာလဲ။</h2>
<p>Go တွင် <strong>Package</strong> ဆိုသည်မှာ code များကို စုစည်းရန်နှင့် organize လုပ်ရန်အတွက် အသုံးပြုသော mechanism တစ်ခုဖြစ်သည်။ ရိုးရှင်းစွာဆိုရလျှင်၊ directory တစ်ခုအတွင်းရှိ Go source file များအားလုံးသည် package တစ်ခုတည်းကို ဖွဲ့စည်းထားသည်။</p>
<ul>
<li>Directory တစ်ခုတည်းရှိ file အားလုံးသည် package name တူညီရမည်။</li>
<li>Package name ကို source file တိုင်း၏ ထိပ်ဆုံးတွင် <code>package &lt;name&gt;</code> ဟု ကြေညာရသည်။</li>
<li>Executable program များအတွက် package name သည် <code>main</code> ဖြစ်ရမည်။ အခြား library package များအတွက် directory name နှင့် တူညီသော package name ကို အသုံးပြုလေ့ရှိသည်။</li>
</ul>
<pre><code class="lang-mermaid">graph TD
    subgraph &quot;Project Directory: myapp&quot;
        subgraph &quot;Directory: calculator&quot;
            File1[&quot;add.go&lt;br/&gt;(package calculator)&quot;]
            File2[&quot;subtract.go&lt;br/&gt;(package calculator)&quot;]
        end
        MainFile[&quot;main.go&lt;br/&gt;(package main)&quot;]
    end

    MainFile -- &quot;imports&quot; --&gt; calculator</code></pre>
<h2 id="standard-library-packages-import-">Standard Library မှ Packages များကို <code>import</code> လုပ်ခြင်း</h2>
<p>Go တွင် အသုံးဝင်သော functions နှင့် types များစွာပါဝင်သည့် standard library တစ်ခု ပါရှိသည်။ ဤ packages များကို အသုံးပြုရန် <code>import</code> keyword ကို အသုံးပြုရသည်။</p>
<pre><code class="lang-go">package main

// Multiple packages များကို import လုပ်ခြင်း
import (
    &quot;fmt&quot;
    &quot;math&quot;
    &quot;strings&quot;
)

func main() {
    fmt.Println(&quot;Pi is roughly&quot;, math.Pi)
    fmt.Println(strings.ToUpper(&quot;hello world&quot;))
}</code></pre>
<h3 id="import-aliases-blank-imports">Import Aliases နှင့် Blank Imports</h3>
<ul>
<li><strong>Alias:</strong> Package name တူညီနေပါက သို့မဟုတ် ပိုတိုသော အမည် ဖြင့် ခေါ်လိုပါက alias သတ်မှတ်နိုင်သည်။<pre><code class="lang-go">import f &quot;fmt&quot; // &quot;fmt&quot; အစား &quot;f&quot; ဖြင့် ခေါ်နိုင်သည်</code></pre>
</li>
<li><strong>Blank Identifier (<code>_</code>):</strong> Package ကို တိုက်ရိုက်အသုံးမပြုသော်လည်း ၎င်း၏ side-effects (ဥပမာ- <code>init</code> function ကို run စေခြင်း) အတွက်သာ import လုပ်လိုပါက blank identifier <code>_</code> ကို အသုံးပြုသည်။ Database drivers များကို import လုပ်ရာတွင် ဤပုံစံကို တွေ့ရလေ့ရှိသည်။<pre><code class="lang-go">import _ &quot;github.com/go-sql-driver/mysql&quot;</code></pre>
</li>
</ul>
<h2 id="-package-">ကိုယ်ပိုင် Package များ တည်ဆောက်ခြင်း</h2>
<p>Project ကြီးမားလာသည်နှင့်အမျှ code များကို သက်ဆိုင်ရာ package များအဖြစ် ခွဲထုတ်ရန် လိုအပ်လာသည်။</p>
<h3 id="exported-vs-unexported-names">Exported vs. Unexported Names</h3>
<p>Go တွင် package တစ်ခုမှ အခြား package တစ်ခုက ခေါ်ယူသုံးစွဲနိုင်ရန်အတွက် ထိုအရာ (variable, function, struct, etc.) ၏ အမည်ကို <strong>စာလုံးအကြီး (uppercase letter)</strong> ဖြင့် စတင်ရမည်။ ၎င်းကို &quot;exported&quot; ဟုခေါ်သည်။</p>
<p>အမည်ကို <strong>စာလုံးအသေး (lowercase letter)</strong> ဖြင့် စတင်ပါက ၎င်းကို package အတွင်းမှာသာ အသုံးပြုနိုင်ပြီး အခြား package များမှ ခေါ်ယူသုံးစွဲနိုင်မည် မဟုတ်ပါ။ ၎င်းကို &quot;unexported&quot; ဟုခေါ်သည်။</p>
<h3 id="-calculator-package-">ဥပမာ: <code>calculator</code> package တည်ဆောက်ခြင်း</h3>
<p><strong>Project File Structure:</strong></p>
<pre><code>myproject/
├── go.mod
├── main.go
└── calculator/
    └── calc.go</code></pre>
<p><strong>1. <code>calculator/calc.go</code> (Library Package)</strong></p>
<pre><code class="lang-go">package calculator

// &#39;Add&#39; function သည် စာလုံးအကြီးဖြင့် စသောကြောင့် exported ဖြစ်သည်
func Add(a, b int) int {
    return a + b
}

// &#39;secretValue&#39; သည် စာလုံးအသေးဖြင့် စသောကြောင့် unexported ဖြစ်သည်
var secretValue = 123</code></pre>
<p><strong>2. <code>main.go</code> (Executable Package)</strong></p>
<pre><code class="lang-go">package main

import (
    &quot;fmt&quot;
    &quot;myproject/calculator&quot; // ကိုယ်ပိုင် package ကို import လုပ်ခြင်း
)

func main() {
    sum := calculator.Add(10, 5)
    fmt.Println(&quot;The sum is:&quot;, sum)

    // အောက်ပါ code line သည် compile error ဖြစ်စေပါမည်
    // အဘယ်ကြောင့်ဆိုသော် &#39;secretValue&#39; သည် unexported ဖြစ်သောကြောင့် main package မှ ခေါ်ယူသုံးစွဲ၍မရပါ
    // fmt.Println(calculator.secretValue)
}</code></pre>
<h2 id="-init-function-initialization-"><code>init()</code> Function (Initialization)</h2>
<p><code>init()</code> function သည် အထူး function တစ်ခုဖြစ်ပြီး package တစ်ခု initialize လုပ်ရာတွင် အသုံးပြုသည်။ <code>main()</code> function မစလုပ်မီ Go runtime က <code>init()</code> ကို အလိုအလျောက် ခေါ်ယူပေးသည်။</p>
<ul>
<li>Parameter နှင့် Return value မရှိရပါ။</li>
<li>Package တစ်ခုတွင် <code>init()</code> function တစ်ခုထက်ပို၍ ရှိနိုင်သည် (သို့သော် တစ်ခုသာထားရန် အကြံပြုသည်)။</li>
<li>အဓိကအားဖြင့် setup variable များသတ်မှတ်ရန်၊ database connection အစပျိုးရန် သို့မဟုတ် registry များတွင် register လုပ်ရန် အသုံးပြုသည်။</li>
</ul>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

var config string

// main မတိုင်မီ အလုပ်လုပ်သည်
func init() {
    config = &quot;LOADED&quot;
    fmt.Println(&quot;Initializing...&quot;)
}

func main() {
    fmt.Println(&quot;Main started with config:&quot;, config)
}

// Output:
// Initializing...
// Main started with config: LOADED</code></pre>
<h2 id="circular-dependencies-">Circular Dependencies (သတိပြုရန်)</h2>
<p>Go တွင် Package A က Package B ကို import လုပ်ပြီး၊ Package B က Package A ကို ပြန်လည် import လုပ်ခြင်း (Circular Dependency) ကို <strong>ခွင့်မပြုပါ</strong>။ Compiler error တက်ပါလိမ့်မည်။</p>
<pre><code class="lang-mermaid">graph LR
    A[Package A] -- imports --&gt; B[Package B]
    B -- imports --&gt; A
    style A fill:#ffcccc,stroke:#333,stroke-width:2px
    style B fill:#ffcccc,stroke:#333,stroke-width:2px</code></pre>
<p><strong>ဖြေရှင်းနည်း:</strong></p>
<ol>
<li>Shared code များကို Package C (Third package) အဖြစ် ခွဲထုတ်ပြီး A နှင့် B နှစ်ခုလုံးက C ကို import လုပ်ပါ။</li>
<li>Package structure ကို ပြန်လည်သုံးသပ်ပြီး design ပြောင်းလဲပါ။</li>
</ol>
<h2 id="go-modules-dependencies-">Go Modules ကို အသုံးပြု၍ Dependencies များကို စီမံခန့်ခွဲခြင်း</h2>
<p><strong>Go Modules</strong> သည် Go project များ၏ dependencies (အခြား packages များအပေါ် မှီခိုမှု) များကို စီမံခန့်ခွဲသည့် စနစ်ဖြစ်သည်။ Project တစ်ခုကို module အဖြစ် သတ်မှတ်လိုက်သည်နှင့် Go က လိုအပ်သော packages များကို download လုပ်ခြင်း၊ version များကို မှတ်သားခြင်းတို့ကို အလိုအလျောက် ပြုလုပ်ပေးသည်။</p>
<h3 id="-commands-">အဓိက Commands များ</h3>
<ul>
<li><p><strong><code>go mod init &lt;module-path&gt;</code></strong></p>
<ul>
<li>Project directory တွင် module အသစ်တစ်ခု စတင်ရန် အသုံးပြုသည်။ <code>module-path</code> သည် များသောအားဖြင့် GitHub repository path (e.g., <code>github.com/your-user/myproject</code>) ဖြစ်သည်။</li>
<li>ဤ command သည် <code>go.mod</code> file ကို ဖန်တီးပေးသည်။</li>
</ul>
<pre><code class="lang-sh"># ဥပမာ
go mod init github.com/aung/myproject</code></pre>
</li>
<li><p><strong><code>go get &lt;package-path&gt;</code></strong></p>
<ul>
<li>Third-party package အသစ်တစ်ခုကို download လုပ်ပြီး dependency အဖြစ် <code>go.mod</code> file ထဲသို့ ထည့်သွင်းရန် အသုံးပြုသည်။</li>
</ul>
<pre><code class="lang-sh"># ဥပမာ: gorilla/mux router ကို download လုပ်ခြင်း
go get github.com/gorilla/mux</code></pre>
</li>
<li><p><strong><code>go mod tidy</code></strong></p>
<ul>
<li>Source code ထဲရှိ <code>import</code> statements များကို စစ်ဆေးပြီး <code>go.mod</code> file ကို update လုပ်ပေးသည်။ အသုံးမပြုတော့သော dependencies များကို ဖယ်ရှားပြီး၊ လိုအပ်နေသော dependencies များကို ထည့်သွင်းပေးသည်။</li>
</ul>
</li>
</ul>
<h3 id="-go-mod-go-sum-files"><code>go.mod</code> နှင့် <code>go.sum</code> Files</h3>
<ul>
<li><p><strong><code>go.mod</code> file:</strong></p>
<ul>
<li>Module ၏ path ကို သတ်မှတ်သည်။</li>
<li>Project က အသုံးပြုနေသော Go version ကို သတ်မှတ်သည်။</li>
<li>Project ၏ direct နှင့် indirect dependencies အားလုံးနှင့် ၎င်းတို့၏ version များကို စာရင်းပြုစုထားသည်။</li>
</ul>
<pre><code>module github.com/aung/myproject

go 1.18

require (
    github.com/gorilla/mux v1.8.0
    github.com/lib/pq v1.10.7
)</code></pre>
</li>
<li><strong><code>go.sum</code> file:</strong><ul>
<li>Dependency တိုင်း၏ cryptographic checksum (hash) ကို မှတ်သားထားသည်။</li>
<li><code>go build</code> လုပ်သည့်အခါ download လုပ်လာသော package သည် မူလ package အစစ်အမှန်ဖြစ်ကြောင်းနှင့် ကြားဖြတ်ပြောင်းလဲထားခြင်းမရှိကြောင်း ဤ file ဖြင့် တိုက်ဆိုင်စစ်ဆေးသည်။ ၎င်းသည် supply chain attacks များမှ ကာကွယ်ပေးသည်။</li>
</ul>
</li>
</ul>
<h2 id="go-workspaces-multi-module-workspaces-">Go Workspaces (Multi-Module Workspaces)</h2>
<p>Go 1.18 တွင် မိတ်ဆက်ခဲ့သော <strong>Go Workspaces</strong> သည် local machine ပေါ်ရှိ module များစွာကို တပြိုင်နက်တည်း အလုပ်လုပ်ရာတွင် လွယ်ကူစေသည်။ <code>go.mod</code> file များကို <code>replace</code> directive ဖြင့် ပြင်ဆင်စရာမလိုဘဲ local module များကို ညွှန်းဆိုနိုင်သည်။</p>
<p><strong>အသုံးပြုပုံ:</strong></p>
<ol>
<li><p><strong>Workspace ဖန်တီးခြင်း:</strong></p>
<pre><code class="lang-sh">mkdir myworkspace
cd myworkspace
go work init</code></pre>
<p>၎င်းသည် <code>go.work</code> file ကို ဖန်တီးပေးသည်။</p>
</li>
<li><p><strong>Module များ ထည့်သွင်းခြင်း:</strong></p>
<pre><code class="lang-sh">go work use ./my-app
go work use ./my-library</code></pre>
</li>
</ol>
<p><strong><code>go.work</code> File ဥပမာ:</strong></p>
<pre><code class="lang-go">go 1.18

use (
    ./my-app
    ./my-library
)</code></pre>
<p>Workspace mode တွင် run သောအခါ Go command များသည် <code>go.work</code> ထဲရှိ module များကို အဓိကထား အလုပ်လုပ်မည်ဖြစ်ပြီး၊ local directory ထဲရှိ module များကို ဦးစားပေး ခေါ်ယူသုံးစွဲသွားမည်ဖြစ်သည်။</p>
<h1 id="-generics">အခန်း ၁၁: Generics</h1>
<p>Go 1.18 တွင် စတင်မိတ်ဆက်ခဲ့သော အစွမ်းထက်ဆုံး feature တစ်ခုဖြစ်သည့် <strong>Generics</strong> အကြောင်းကို ဤအခန်းတွင် လေ့လာသွားပါမည်။ Generics သည် ကျွန်ုပ်တို့အား data type မည်သို့ပင်ဖြစ်စေ အလုပ်လုပ်နိုင်သော functions နှင့် data structures များကို ရေးသားနိုင်စေပြီး ကျွန်ုပ်တို့၏ code များကို ပိုမို flexible ဖြစ်စေကာ ပြန်လည်အသုံးပြုရလွယ်ကူစေသည်။</p>
<h2 id="generic-">Generic ဆိုတာဘာလဲ။</h2>
<p>Generics ဆိုသည်မှာ တိကျသော data type များပေါ်တွင် မမှီခိုဘဲ အလုပ်လုပ်နိုင်သော code များကို ရေးသားနိုင်သည့် နည်းလမ်းတစ်ခုဖြစ်သည်။ Generics မတိုင်မီက၊ သင်သည် <code>int</code> များအတွက် function တစ်ခုနှင့် <code>float64</code> များအတွက် အလားတူ function တစ်ခု လိုအပ်ပါက၊ function နှစ်ခု သီးသန့် ရေးသားခဲ့ရသည်။ Generics ဖြင့်၊ သင်သည် type အမျိုးမျိုးအတွက် အလုပ်လုပ်နိုင်သော <em>type parameter</em> တစ်ခုကို လက်ခံသည့် function တစ်ခုတည်းကို ရေးသားနိုင်သည်။</p>
<p><strong>Type parameter</strong> ဆိုသည်မှာ function သို့မဟုတ် type ကို အသုံးပြုသည့်အခါ သတ်မှတ်မည့် type အတွက် placeholder တစ်ခုဖြစ်သည်။</p>
<h2 id="generic-functions">Generic Functions</h2>
<p>Generic function ဆိုသည်မှာ type parameters တစ်ခု သို့မဟုတ် တစ်ခုထက်ပို၍ ကြေညာထားသော function ဖြစ်သည်။</p>
<h3 id="-printslice-function">ဥပမာ: <code>PrintSlice</code> Function</h3>
<p>အောက်ပါ diagram သည် Generic function တစ်ခုက မတူညီသော data type များကို မည်သို့ ကိုင်တွယ်သည်ကို ပြသထားသည်။</p>
<pre><code class="lang-mermaid">graph TD
    subgraph &quot;Generic Function Definition&quot;
        Def[&quot;func PrintSlice[T any](s []T)&quot;]
    end

    subgraph &quot;Function Calls&quot;
        CallInt[&quot;PrintSlice([]int{1, 2})&quot;]
        CallStr[&quot;PrintSlice([]string{&#39;a&#39;, &#39;b&#39;})&quot;]
    end

    subgraph &quot;Type Instantiation (Compiler Logic)&quot;
        InstInt[&quot;T becomes int&lt;br/&gt;func PrintSlice(s []int)&quot;]
        InstStr[&quot;T becomes string&lt;br/&gt;func PrintSlice(s []string)&quot;]
    end

    CallInt --&gt;|&quot;T = int&quot;| InstInt
    CallStr --&gt;|&quot;T = string&quot;| InstStr

    InstInt -.-&gt; Def
    InstStr -.-&gt; Def</code></pre>
<p>မည်သည့် type မဆိုရှိသော slice ၏ elements များကို print ထုတ်နိုင်သော function တစ်ခု ရေးကြည့်ကြပါစို့။</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

// T သည် မည်သည့် type မဆို ဖြစ်နိုင်သော type parameter ဖြစ်သည်။
func PrintSlice[T any](s []T) {
    for _, v := range s {
        fmt.Printf(&quot;%v &quot;, v)
    }
    fmt.Println()
}

func main() {
    // integer slice ဖြင့် PrintSlice ကို ခေါ်ယူခြင်း
    intSlice := []int{1, 2, 3, 4}
    fmt.Print(&quot;Integer Slice: &quot;)
    PrintSlice(intSlice) // Go သည် T type ကို int အဖြစ် အလိုအလျောက်သိရှိသည်

    // string slice ဖြင့် PrintSlice ကို ခေါ်ယူခြင်း
    stringSlice := []string{&quot;Hello&quot;, &quot;World&quot;, &quot;Go&quot;}
    fmt.Print(&quot;String Slice: &quot;)
    PrintSlice(stringSlice) // Go သည် T type ကို string အဖြစ် အလိုအလျောက်သိရှိသည်
}</code></pre>
<p>ဤဥပမာတွင်၊ <code>[T any]</code> သည် <code>T</code> ဆိုသော type parameter ကို ကြေညာသည်။ <code>any</code> keyword သည် <code>T</code> ၏ type မည်သို့မဆို ဖြစ်နိုင်သည်ဟု ဆိုလိုသော <em>constraint</em> တစ်ခုဖြစ်သည်။ ကျွန်ုပ်တို့ <code>PrintSlice(intSlice)</code> ကို ခေါ်သောအခါ၊ Go compiler သည် <code>T</code> ကို <code>int</code> ဖြစ်သည်ဟု ကောက်ချက်ချသည်။</p>
<h2 id="generic-types">Generic Types</h2>
<p>ကျွန်ုပ်တို့သည် မည်သည့် type နှင့်မဆို အလုပ်လုပ်သော struct သို့မဟုတ် interface ကဲ့သို့သော generic type များကိုလည်း သတ်မှတ်နိုင်သည်။</p>
<h3 id="-generic-stack-data-structure">ဥပမာ: Generic <code>Stack</code> Data Structure</h3>
<p>မည်သည့် type ၏ value များကိုမဆို သိမ်းဆည်းနိုင်သော <code>Stack</code> တစ်ခုကို တည်ဆောက်ကြည့်ကြပါစို့။</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

// Stack သည် T type ရှိသော slice တစ်ခုကို ကိုင်ထားသည်။
type Stack[T any] struct {
    items []T
}

// Push သည် T type ရှိသော item တစ်ခုကို stack သို့ ထည့်ပေးသည်။
func (s *Stack[T]) Push(item T) {
    s.items = append(s.items, item)
}

// Pop သည် stack မှ နောက်ဆုံး item ကို ဖယ်ရှားပြီး ပြန်ပေးသည်။
func (s *Stack[T]) Pop() (T, bool) {
    if len(s.items) == 0 {
        var zero T // T type အတွက် သုညတန်ဖိုး (zero value) ကို ပြန်ပေးသည်
        return zero, false
    }
    lastIndex := len(s.items) - 1
    item := s.items[lastIndex]
    s.items = s.items[:lastIndex]
    return item, true
}

func main() {
    // integer များအတွက် stack တစ်ခု တည်ဆောက်ခြင်း
    intStack := Stack[int]{}
    intStack.Push(10)
    intStack.Push(20)
    val, _ := intStack.Pop()
    fmt.Printf(&quot;Popped from intStack: %d\n&quot;, val)

    // string များအတွက် stack တစ်ခု တည်ဆောက်ခြင်း
    stringStack := Stack[string]{}
    stringStack.Push(&quot;apple&quot;)
    stringStack.Push(&quot;banana&quot;)
    strVal, _ := stringStack.Pop()
    fmt.Printf(&quot;Popped from stringStack: %s\n&quot;, strVal)
}</code></pre>
<p>ဤနေရာတွင်၊ <code>Stack[T any]</code> သည် <code>T</code> ဆိုသော type parameter ဖြင့် <code>Stack</code> struct ကို သတ်မှတ်သည်။ ထို့နောက် <code>Stack[int]</code> သို့မဟုတ် <code>Stack[string]</code> ကဲ့သို့သော instance များကို ဖန်တီးနိုင်သည်။</p>
<h2 id="type-constraints">Type Constraints</h2>
<p>တစ်ခါတစ်ရံတွင်၊ type parameters အဖြစ် အသုံးပြုနိုင်သော type များကို ကန့်သတ်ရန် လိုအပ်သည်။ ဥပမာအားဖြင့်၊ သင်သည် ကိန်းဂဏန်းများပေါ်တွင်သာ အလုပ်လုပ်သော function တစ်ခုကို ရေးလိုပေမည်။ ဤနေရာတွင် <strong>type constraints</strong> များ ဝင်လာပါသည်။</p>
<p>Constraint ဆိုသည်မှာ type parameter အတွက် ခွင့်ပြုထားသော type များ၏ set ကို သတ်မှတ်သည့် interface တစ်ခုဖြစ်သည်။</p>
<h3 id="-sumnumbers-function">ဥပမာ: <code>SumNumbers</code> Function</h3>
<p>Slice တစ်ခုရှိ value များကို ပေါင်းရန် generic function တစ်ခု ဖန်တီးကြပါစို့၊ သို့သော် integer နှင့် float type များအတွက်သာ ဖြစ်သည်။</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

// Number သည် မည်သည့် integer သို့မဟုတ် floating-point type ကိုမဆို ခွင့်ပြုသော constraint တစ်ခုဖြစ်သည်။
type Number interface {
    ~int | ~int32 | ~int64 | ~float32 | ~float64
}

// SumNumbers သည် Number constraint နှင့် ကိုက်ညီသော type ၏ elements များပါဝင်သည့်
// slice တစ်ခု၏ value များကို ပေါင်းပေးသည်။
func SumNumbers[T Number](numbers []T) T {
    var sum T
    for _, n := range numbers {
        sum += n
    }
    return sum
}

func main() {
    intSlice := []int{1, 2, 3, 4}
    fmt.Printf(&quot;Sum of ints: %d\n&quot;, SumNumbers(intSlice))

    floatSlice := []float64{1.1, 2.2, 3.3}
    fmt.Printf(&quot;Sum of floats: %f\n&quot;, SumNumbers(floatSlice))

    // အောက်ပါ line သည် compile-time error ဖြစ်စေပါလိမ့်မည်
    // အဘယ်ကြောင့်ဆိုသော် string သည် Number constraint ကို မကျေနပ်သောကြောင့်ဖြစ်သည်။
    // stringSlice := []string{&quot;a&quot;, &quot;b&quot;}
    // SumNumbers(stringSlice)
}</code></pre>
<p>ဤဥပမာတွင်၊ ကျွန်ုပ်တို့သည် အမျိုးမျိုးသော integer နှင့် float type များ ပါဝင်သော <code>Number</code> interface ကို သတ်မှတ်သည်။ <code>~</code> သင်္ကေတသည် <code>int</code> သာမက၊ underlying type မှာ <code>int</code> ဖြစ်သော မည်သည့် type (custom type <code>type MyInt int</code> ကဲ့သို့) ကိုမဆို ခွင့်ပြုသည်ဟု ဆိုလိုသည်။ <code>[T Number]</code> ကို အသုံးပြုခြင်းဖြင့်၊ <code>SumNumbers</code> ကို <code>Number</code> constraint ၏ အစိတ်အပိုင်းဖြစ်သော type များ၏ slice များဖြင့်သာ ခေါ်ဆိုနိုင်သည်ဟု compiler ကို ပြောပြသည်။</p>
<h2 id="built-in-comparable-constraint">Built-in <code>comparable</code> Constraint</h2>
<p>Go တွင် <code>equality</code> (<code>==</code> နှင့် <code>!=</code>) ကို စစ်ဆေးရန်အတွက် အသင့်ပါရှိပြီးသား <code>comparable</code> constraint ကို အသုံးပြုနိုင်သည်။ <code>any</code> constraint သည် အရာအားလုံးကို လက်ခံသော်လည်း <code>==</code> စစ်ဆေးခြင်းကို ခွင့်မပြုပါ။</p>
<h3 id="-slice-index-function">ဥပမာ: Slice Index ရှာဖွေခြင်း Function</h3>
<p>Slice တစ်ခုထဲတွင် element တစ်ခု ရှိမရှိ ရှာဖွေသော function ကို ရေးကြည့်ကြပါစို့။ ဤနေရာတွင် value များကို နှိုင်းယှဉ်ရန် လိုအပ်သောကြောင့် <code>comparable</code> ကို သုံးရပါမည်။</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

// Index သည် slice s ထဲတွင် x ရှိသော index ကို ပြန်ပေးသည်။ မရှိလျှင် -1 ပြန်ပေးသည်။
// T သည် comparable ဖြစ်ရမည် (ဆိုလိုသည်မှာ == နှင့် != ကို support လုပ်ရမည်)
func Index[T comparable](s []T, x T) int {
    for i, v := range s {
        // v နှင့် x ကို နှိုင်းယှဉ်နိုင်သည်
        if v == x {
            return i
        }
    }
    return -1
}

func main() {
    // Int slice
    si := []int{10, 20, 15, -10}
    fmt.Println(Index(si, 15)) // Output: 2

    // String slice
    ss := []string{&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;}
    fmt.Println(Index(ss, &quot;hello&quot;)) // Output: -1
}</code></pre>
<p>ဤ function သည် <code>int</code>, <code>string</code>, <code>bool</code>, <code>pointer</code> စသည့် <code>comparable</code> ဖြစ်သော မည်သည့် type နှင့်မဆို အလုပ်လုပ်သည်။</p>
<h1 id="-goroutines">အခန်း ၁၂: Goroutines</h1>
<p>ယခုအခန်းတွင် Go ၏ အကျော်ကြားဆုံးနှင့် အစွမ်းထက်ဆုံး feature ဖြစ်သော concurrency ကို စတင်လေ့လာပါမည်။ Go သည် Goroutines ဟုခေါ်သော အလွန်ပေါ့ပါးသည့် execution unit များကို အသုံးပြု၍ concurrent programming ကို အလွန်လွယ်ကူအောင် ပြုလုပ်ပေးထားသည်။</p>
<h2 id="concurrency-parallelism-">Concurrency နှင့် Parallelism ကွာခြားချက်</h2>
<p>Concurrency နှင့် Parallelism သည် ဆင်တူသယောင်ရှိသော်လည်း အဓိပ္ပာယ် မတူညီပါ။</p>
<ul>
<li><p><strong>Concurrency (တစ်ပြိုင်နက်တည်း စီမံခန့်ခွဲခြင်း):</strong> လုပ်ငန်းတာဝန် (tasks) များစွာကို တစ်ချိန်တည်းတွင် စီမံခန့်ခွဲနိုင်စွမ်းရှိခြင်း ဖြစ်သည်။ Task တစ်ခုကို လုပ်ဆောင်နေစဉ် ခေတ္တရပ်နားပြီး အခြား task တစ်ခုကို ပြောင်းလဲလုပ်ဆောင်နိုင်သည်။ ၎င်းသည် <strong>လုပ်ငန်းများကို စီမံခန့်ခွဲသည့် ပုံစံ (structure)</strong> ဖြစ်ပြီး တစ်ပြိုင်နက်တည်း အမှန်တကယ် run နေရန် မလိုအပ်ပါ။</p>
</li>
<li><p><strong>Parallelism (တစ်ပြိုင်နက်တည်း လုပ်ဆောင်ခြင်း):</strong> လုပ်ငန်းတာဝန်များစွာကို တစ်ချိန်တည်းတွင် အမှန်တကယ် <strong>တစ်ပြိုင်နက်တည်း လုပ်ဆောင်ခြင်း</strong> ဖြစ်သည်။ ၎င်းကို multi-core processor များပေါ်တွင်သာ လုပ်ဆောင်နိုင်ပြီး core တစ်ခုချင်းစီက task တစ်ခုစီကို တစ်ချိန်တည်းမှာပင် လုပ်ဆောင်ပါသည်။</p>
</li>
</ul>
<pre><code class="lang-mermaid">graph TD
    subgraph &quot;Concurrency (Single CPU Core)&quot;
        direction LR
        CPU1[&quot;CPU Core&quot;]
        T1[&quot;Task A&quot;]
        T2[&quot;Task B&quot;]
        T3[&quot;Task C&quot;]
        CPU1 -- &quot;switches to&quot; --&gt; T1 -- &quot;switches to&quot; --&gt; T2 -- &quot;switches to&quot; --&gt; T3
    end

    subgraph &quot;Parallelism (Multi-Core)&quot;
        CPU_A[&quot;CPU Core 1&quot;] -- &quot;runs&quot; --&gt; Task_A[&quot;Task A&quot;]
        CPU_B[&quot;CPU Core 2&quot;] -- &quot;runs&quot; --&gt; Task_B[&quot;Task B&quot;]
    end</code></pre>
<p>Go သည် concurrency ကို အဓိကထား ဒီဇိုင်းထုတ်ထားပြီး၊ multi-core processor များရှိပါက Go runtime က goroutines များကို cores များပေါ်တွင် parallel အဖြစ် အလိုအလျောက် run ပေးပါသည်။</p>
<h2 id="goroutine-go-keyword-">Goroutine ဆိုတာဘာလဲ။ (<code>go</code> keyword)</h2>
<p><strong>Goroutine</strong> ဆိုသည်မှာ Go runtime မှ စီမံခန့်ခွဲသော အလွန်ပေါ့ပါးသည့် thread (lightweight thread) တစ်ခုဖြစ်သည်။ OS thread များနှင့် နှိုင်းယှဉ်ပါက memory အသုံးပြုမှု အလွန်နည်းပါးပြီး (kilobytes အနည်းငယ်သာ)၊ ဖန်တီးရန်နှင့် ဖျက်သိမ်းရန် အလွန်မြန်ဆန်သည်။ ထို့ကြောင့် goroutines ထောင်ပေါင်းများစွာ၊ သိန်းပေါင်းများစွာကို တစ်ပြိုင်နက်တည်း run နိုင်ပါသည်။</p>
<p>Function call တစ်ခု၏ ရှေ့တွင် <code>go</code> keyword ကို ထည့်သွင်းလိုက်ရုံဖြင့် goroutine အသစ်တစ်ခုကို အလွယ်တကူ ဖန်တီးနိုင်ပါသည်။</p>
<pre><code class="lang-go">package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func say(s string) {
    for i := 0; i &lt; 3; i++ {
        fmt.Println(s)
        time.Sleep(100 * time.Millisecond)
    }
}

func main() {
    // &#39;say&#39; function ကို goroutine အသစ်တစ်ခုအနေဖြင့် run မည်
    go say(&quot;World&quot;)

    // main function (main goroutine) က ဆက်လက် run နေမည်
    say(&quot;Hello&quot;)
}</code></pre>
<p><strong>ပြဿနာ:</strong> အထက်ပါ code ကို run ကြည့်ပါက &quot;Hello&quot; ကိုသာ print ထုတ်ပြီး &quot;World&quot; ကို print ထုတ်သည်ကို မြင်ရချင်မှ မြင်ရမည်။ အကြောင်းမှာ <code>main</code> function (main goroutine) သည် <code>say(&quot;World&quot;)</code> goroutine ပြီးဆုံးသည်ကို <strong>မစောင့်ဘဲ</strong> ၎င်း၏အလုပ် ပြီးဆုံးသွားသည်နှင့် program တစ်ခုလုံးကို ရပ်တန့်လိုက်သောကြောင့် ဖြစ်သည်။</p>
<h2 id="-sync-waitgroup-"><code>sync.WaitGroup</code> ကို အသုံးပြုခြင်း</h2>
<p>Goroutines များအားလုံး ပြီးဆုံးသည်အထိ main goroutine ကို စောင့်ဆိုင်းစေရန်အတွက် <code>sync</code> package မှ <code>WaitGroup</code> ကို အသုံးပြုနိုင်ပါသည်။ <code>WaitGroup</code> သည် goroutines အစုအဝေးတစ်ခု ပြီးဆုံးသည်အထိ စောင့်ဆိုင်းရန်အတွက် counter တစ်ခုကို အသုံးပြုသည်။</p>
<p><code>WaitGroup</code> တွင် အဓိက method ၃ ခုရှိသည်:</p>
<ol>
<li><strong><code>Add(delta int)</code>:</strong> Counter ကို <code>delta</code> တန်ဖိုး만큼 တိုးရန်။ စတင်မည့် goroutine အရေအတွက်ကို သတ်မှတ်ရန် အသုံးပြုသည်။</li>
<li><strong><code>Done()</code>:</strong> Counter ကို ၁ လျှော့ရန်။ Goroutine တစ်ခု ပြီးဆုံးသည့်အခါ ခေါ်ယူရသည်။</li>
<li><strong><code>Wait()</code>:</strong> Counter ၏ တန်ဖိုး 0 ဖြစ်သွားသည်အထိ (goroutines အားလုံး <code>Done()</code> ခေါ်ပြီးသည်အထိ) program ၏ execution ကို block လုပ်ထားရန် (စောင့်ဆိုင်းရန်)။</li>
</ol>
<pre><code class="lang-mermaid">graph TD
    A[Main Goroutine] -- &quot;wg.Add(2)&quot; --&gt; B{WaitGroup Counter = 2}
    A -- &quot;go worker(1)&quot; --&gt; C[Worker 1]
    A -- &quot;go worker(2)&quot; --&gt; D[Worker 2]
    A -- &quot;wg.Wait()&quot; --&gt; F{Blocks until Counter is 0}

    C -- &quot;does work&quot; --&gt; G[&quot;...&quot;]
    D -- &quot;does work&quot; --&gt; H[&quot;...&quot;]

    G -- &quot;wg.Done()&quot; --&gt; I{Counter = 1}
    H -- &quot;wg.Done()&quot; --&gt; J{Counter = 0}

    J -- &quot;unblocks&quot; --&gt; F
    F --&gt; K[Continue Execution]</code></pre>
<p><strong><code>WaitGroup</code> ဖြင့် ပြင်ဆင်ထားသော ဥပမာ:</strong></p>
<pre><code class="lang-go">package main

import (
    &quot;fmt&quot;
    &quot;sync&quot;
    &quot;time&quot;
)

func worker(id int, wg *sync.WaitGroup) {
    // Goroutine ပြီးဆုံးသည့်အခါ WaitGroup counter ကို လျှော့ရန် defer ဖြင့် ကြိုတင်သတ်မှတ်ထားသည်
    defer wg.Done()

    fmt.Printf(&quot;Worker %d starting\n&quot;, id)

    // အလုပ်လုပ်နေသည်ကို ပုံဖော်ရန် sleep လုပ်ခြင်း
    time.Sleep(time.Second)
    fmt.Printf(&quot;Worker %d done\n&quot;, id)
}

func main() {
    // WaitGroup variable တစ်ခု တည်ဆောက်ခြင်း
    var wg sync.WaitGroup

    // Worker goroutines ၃ ခုကို run မည်
    for i := 1; i &lt;= 3; i++ {
        // WaitGroup counter ကို ၁ တိုးသည်
        wg.Add(1)

        // worker function ကို goroutine အဖြစ် run ပြီး WaitGroup pointer ကို pass လုပ်သည်
        go worker(i, &amp;wg)
    }

    // Goroutines အားလုံး ပြီးဆုံးသည်အထိ ဤနေရာတွင် စောင့်ဆိုင်းနေမည်
    wg.Wait()

    fmt.Println(&quot;All workers have finished.&quot;)
}</code></pre>
<p>ဤ code တွင် <code>main</code> function သည် <code>wg.Wait()</code> နေရာတွင် worker goroutines ၃ ခုလုံး <code>wg.Done()</code> ကို ခေါ်ပြီးသည်အထိ စောင့်ဆိုင်းနေမည်ဖြစ်သောကြောင့် worker များအားလုံး၏ output များကို စနစ်တကျ မြင်တွေ့ရမည်ဖြစ်သည်။</p>
<h2 id="race-conditions-sync-mutex-">Race Conditions နှင့် <code>sync.Mutex</code></h2>
<p>Goroutines များစွာက variable တစ်ခုတည်းကို တစ်ပြိုင်နက်တည်း ပြောင်းလဲရန် ကြိုးစားသောအခါ <strong>Race Condition</strong> ဖြစ်ပေါ်တတ်သည်။ ၎င်းသည် program ၏ ရလဒ်ကို မမှန်ကန်စေဘဲ၊ ရှာဖွေရခက်ခဲသော bug များကို ဖြစ်စေသည်။</p>
<p>ဤပြဿနာကို ဖြေရှင်းရန် <code>sync.Mutex</code> (Mutual Exclusion lock) ကို အသုံးပြုသည်။ <code>Mutex</code> သည် ကုဒ်၏ အစိတ်အပိုင်းတစ်ခုကို တစ်ချိန်တည်းတွင် goroutine တစ်ခုတည်းကသာ လုပ်ဆောင်ခွင့်ရစေရန် lock ချပေးသည်။</p>
<h3 id="race-condition-">Race Condition ဥပမာ (ပြဿနာ)</h3>
<p>အောက်ပါ code တွင် goroutine 1000 ခုက <code>counter</code> ကို တိုးရန် ကြိုးစားသည်။ Lock မရှိသောကြောင့် <code>counter</code> ၏ တန်ဖိုးသည် 1000 ဖြစ်လာမည် မဟုတ်ပါ။</p>
<pre><code class="lang-go">var counter = 0

func increment(wg *sync.WaitGroup) {
    defer wg.Done()
    counter++ // Race Condition ဖြစ်မည့်နေရာ
}
// ရလဒ်: 1000 ထက် လျော့နည်းနေလေ့ရှိသည် (ဥပမာ - 980)</code></pre>
<h3 id="-sync-mutex-"><code>sync.Mutex</code> ဖြင့် ဖြေရှင်းခြင်း</h3>
<pre><code class="lang-go">package main

import (
    &quot;fmt&quot;
    &quot;sync&quot;
)

var (
    counter = 0
    mu      sync.Mutex // Mutex ကြေညာခြင်း
)

func increment(wg *sync.WaitGroup) {
    defer wg.Done()

    // Critical Section မစမီ Lock ချသည်
    mu.Lock()
    counter++
    // ပြီးဆုံးပါက Unlock ပြန်လုပ်သည်
    mu.Unlock()
}

func main() {
    var wg sync.WaitGroup
    for i := 0; i &lt; 1000; i++ {
        wg.Add(1)
        go increment(&amp;wg)
    }
    wg.Wait()
    fmt.Println(&quot;Final Counter:&quot;, counter) // Output: 1000 (Correct)
}</code></pre>
<h2 id="singleton-pattern-sync-once-">Singleton Pattern (<code>sync.Once</code>)</h2>
<p>Struct များနှင့် ပတ်သက်၍ အသုံးများသော Design Pattern တစ်ခုမှာ <strong>Singleton Pattern</strong> ဖြစ်သည်။ Singleton ဆိုသည်မှာ Application တစ်ခုလုံးတွင် struct instance တစ်ခုတည်းသာ ရှိစေရန် ကန့်သတ်ထားခြင်းဖြစ်သည်။ Concurrency ပါဝင်သော Application များတွင် Singleton ကို thread-safe ဖြစ်စေရန် <code>sync</code> package မှ <code>Once</code> ကို အသုံးပြုတည်ဆောက်လေ့ရှိသည်။</p>
<pre><code class="lang-go">package main

import (
    &quot;fmt&quot;
    &quot;sync&quot;
)

type database struct {
    connectionString string
}

var (
    instance *database
    once     sync.Once // Thread-safe ဖြစ်စေရန် အသုံးပြုသည်
)

// GetDatabaseInstance သည် database instance ကို ပြန်ပေးသည်
// ပထမဆုံးအကြိမ် ခေါ်ချိန်တွင်သာ instance ကို ဖန်တီးပြီး၊ နောက်ပိုင်းတွင် ရှိပြီးသားကိုသာ ပြန်ပေးသည်
func GetDatabaseInstance() *database {
    once.Do(func() {
        fmt.Println(&quot;Creating single database instance...&quot;)
        instance = &amp;database{connectionString: &quot;mysql://user:pass@localhost:3306/mydb&quot;}
    })
    return instance
}

func main() {
    var wg sync.WaitGroup

    // Goroutines များစွာက တပြိုင်နက်တည်း Instance ကို ရယူရန် ကြိုးစားခြင်း
    for i := 0; i &lt; 10; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            db := GetDatabaseInstance()
            // အားလုံးသည် memory address အတူတူကိုသာ ရရှိမည်
            fmt.Printf(&quot;DB Instance Address: %p\n&quot;, db)
        }()
    }
    wg.Wait()
}</code></pre>
<p><code>sync.Once</code> သည် <code>Do</code> အတွင်းရှိ function ကို program တစ်ခုလုံးတွင် <strong>တစ်ကြိမ်တည်းသာ</strong> အလုပ်လုပ်စေရန် အာမခံပါသည်။ ထို့ကြောင့် goroutines များစွာက ပြိုင်တူခေါ်လျှင်သော်မှ instance တစ်ခုတည်းသာ ဖန်တီးမည်ဖြစ်ပြီး thread-safe ဖြစ်သည်။</p>
<h3 id="-global-configuration">နောက်ထပ် ဥပမာ: Global Configuration</h3>
<p>Database connection သာမက Application ၏ Configuration (ဥပမာ - API Keys, App Settings) များကို load လုပ်ရာတွင်လည်း Singleton Pattern ကို အသုံးပြုလေ့ရှိသည်။</p>
<pre><code class="lang-go">type Config struct {
    APIKey    string
    DebugMode bool
}

var (
    configInstance *Config
    configOnce     sync.Once
)

func GetConfig() *Config {
    configOnce.Do(func() {
        configInstance = &amp;Config{
            APIKey:    &quot;AABBCC123&quot;,
            DebugMode: true,
        }
    })
    return configInstance
}</code></pre>
<p><strong>သတိပြုရန်:</strong> အထက်ပါ Code တွင် <code>APIKey</code> နှင့် <code>DebugMode</code> သည် Public fields (အကြီးဖြင့်စထားသည်) ဖြစ်သောကြောင့် အပြင်မှ တိုက်ရိုက် ပြင်ဆင်နိုင်သည်။</p>
<pre><code class="lang-go">cfg := GetConfig()
cfg.DebugMode = false // ဤသို့ပြင်လိုက်ပါက Application တစ်ခုလုံးမှ Config ပြောင်းလဲသွားမည်</code></pre>
<p>ဤကဲ့သို့ မလိုလားအပ်သော ပြောင်းလဲမှုများကို ကာကွယ်ရန် <strong>Read-Only Singleton</strong> ပုံစံကို ပြောင်းလဲအသုံးပြုသင့်သည်။</p>
<h3 id="safe-global-configuration-read-only-">Safe Global Configuration (Read-Only)</h3>
<p>Field များကို private (အသေးဖြင့်စ) အဖြစ်ပြောင်းပြီး၊ တန်ဖိုးယူရန် <strong>Getter methods</strong> များကိုသာ ထုတ်ပေးသင့်သည်။</p>
<pre><code class="lang-go">package main

import (
    &quot;fmt&quot;
    &quot;sync&quot;
)

type Config struct {
    apiKey    string // Private field (ပြင်ခွင့်မပေးပါ)
    debugMode bool   // Private field
}

var (
    safeConfigInstance *Config
    safeConfigOnce     sync.Once
)

// Getter Method for APIKey
func (c *Config) APIKey() string {
    return c.apiKey
}

// Getter Method for DebugMode
func (c *Config) DebugMode() bool {
    return c.debugMode
}

func GetSafeConfig() *Config {
    safeConfigOnce.Do(func() {
        fmt.Println(&quot;Loading safe configuration...&quot;)
        safeConfigInstance = &amp;Config{
            apiKey:    &quot;AABBCC123&quot;,
            debugMode: true,
        }
    })
    return safeConfigInstance
}

func main() {
    cfg := GetSafeConfig()

    // Method မှတဆင့် တန်ဖိုးကို ရယူသဖြင့် လုံခြုံမှုရှိသည်
    fmt.Println(&quot;API Key:&quot;, cfg.APIKey())

    // cfg.apiKey = &quot;NewKey&quot; // Error: field သည် private ဖြစ်သောကြောင့် ပြင်၍မရပါ
}</code></pre>
<h1 id="-channels">အခန်း ၁၃: Channels</h1>
<p>ယခင်အခန်းတွင် goroutines များကို အသုံးပြု၍ concurrent tasks များ မည်သို့ run ရမည်ကို လေ့လာခဲ့ပြီးဖြစ်သည်။ ယခုအခန်းတွင် ထို goroutines များ အချင်းချင်း ဘေးကင်းလုံခြုံစွာ ဆက်သွယ်ရန်နှင့် data များ အပြန်အလှန် ပေးပို့ရန်အတွက် Go ၏ အဓိကကျသော feature ဖြစ်သည့် <strong>Channels</strong> အကြောင်းကို လေ့လာသွားပါမည်။</p>
<h2 id="channel-goroutines-">Channel ဆိုတာဘာလဲ။ (Goroutines များကြား ဆက်သွယ်ရေး)</h2>
<p><strong>Channel</strong> ဆိုသည်မှာ goroutines များ အချင်းချင်း data များ ပေးပို့ခြင်း (send) နှင့် လက်ခံခြင်း (receive) ပြုလုပ်နိုင်ရန်အတွက် တည်ဆောက်ထားသော ပိုက်လိုင်း (pipeline) သို့မဟုတ် conduit တစ်ခုဖြစ်သည်။ Channel တိုင်းတွင် သီးခြား data type တစ်ခု သတ်မှတ်ထားပြီး၊ ထို type နှင့် ကိုက်ညီသော data များကိုသာ ပေးပို့ လက်ခံနိုင်ပါသည်။</p>
<p>Go ၏ ဆောင်ပုဒ်မှာ <strong>&quot;Don&#39;t communicate by sharing memory; share memory by communicating.&quot;</strong> ဖြစ်သည်။ ၎င်းမှာ memory ကို goroutines များစွာက တိုက်ရိုက် access လုပ်ခြင်းထက်၊ channel မှတစ်ဆင့် data များကို ပေးပို့ခြင်းဖြင့် ဆက်သွယ်ခြင်းက ပိုမိုဘေးကင်းပြီး ရိုးရှင်းသည်ဟု ဆိုလိုခြင်းဖြစ်သည်။</p>
<h3 id="channel-">Channel ဖန်တီးခြင်း နှင့် အသုံးပြုခြင်း</h3>
<p>Channel ကို <code>make()</code> function ဖြင့် ဖန်တီးသည်။ <code>&lt;-</code> operator ကို data ပေးပို့ရန်နှင့် လက်ခံရန် အသုံးပြုသည်။</p>
<ul>
<li><code>ch &lt;- value</code>  // <code>value</code> ကို channel <code>ch</code> ထဲသို့ ပို့သည်</li>
<li><code>result := &lt;-ch</code> // channel <code>ch</code> မှ data ကို လက်ခံပြီး <code>result</code> ထဲသို့ ထည့်သည်</li>
</ul>
<pre><code class="lang-mermaid">graph TD
    Producer[&quot;Producer Goroutine&quot;] -- &quot;ch &lt;- &#39;Hello&#39;&quot; --&gt; Channel[&quot;Channel (ch)&quot;]
    Channel -- &quot;&#39;Hello&#39; ကို လက်ခံသည်&quot; --&gt; Consumer[&quot;Consumer Goroutine&lt;br/&gt;message := &lt;-ch&quot;]</code></pre>
<p><strong>ဥပမာ:</strong></p>
<pre><code class="lang-go">package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func producer(ch chan string) {
    fmt.Println(&quot;Producer: Sending a message...&quot;)
    time.Sleep(2 * time.Second)
    ch &lt;- &quot;Hello from Producer!&quot;
}

func main() {
    // string type data များ သယ်ဆောင်မည့် channel တစ်ခု ဖန်တီးခြင်း
    messages := make(chan string)

    // producer function ကို goroutine အဖြစ် run ခြင်း
    go producer(messages)

    fmt.Println(&quot;Main: Waiting for a message...&quot;)
    // channel မှ message ရောက်လာသည်အထိ ဤနေရာတွင် block ဖြစ်နေမည် (စောင့်နေမည်)
    msg := &lt;-messages

    fmt.Println(&quot;Main: Received message:&quot;, msg)
}</code></pre>
<h2 id="buffered-vs-unbuffered-channels">Buffered vs. Unbuffered Channels</h2>
<p>Channels များကို unbuffered နှင့် buffered ဟူ၍ နှစ်မျိုးခွဲခြားနိုင်သည်။</p>
<h3 id="unbuffered-channels">Unbuffered Channels</h3>
<p><code>make(chan T)</code> ဖြင့် capacity မသတ်မှတ်ဘဲ ဖန်တီးသော channel များသည် unbuffered ဖြစ်သည်။</p>
<ul>
<li><strong>Send Operation:</strong> Sender goroutine သည် channel ထဲသို့ data ပို့သည့်အခါ receiver goroutine က ထို data ကို လက်ခံရန် အသင့်မဖြစ်သေးပါက sender သည် <strong>block</strong> ဖြစ်နေမည် (ရပ်တန့်စောင့်ဆိုင်းနေမည်)။</li>
<li><strong>Receive Operation:</strong> Receiver goroutine သည် channel မှ data လက်ခံရန် ကြိုးစားသည့်အခါ channel ထဲတွင် data မရှိသေးပါက receiver သည် <strong>block</strong> ဖြစ်နေမည်။</li>
</ul>
<p>Unbuffered channel သည် sender နှင့် receiver ကြားတွင် synchronization (တစ်ပြိုင်တည်း အချိတ်အဆက်မိခြင်း) ကို အာမခံပေးသည်။</p>
<h3 id="buffered-channels">Buffered Channels</h3>
<p><code>make(chan T, capacity)</code> ဖြင့် capacity သတ်မှတ်ပြီး ဖန်တီးသော channel များသည် buffered ဖြစ်သည်။</p>
<ul>
<li><strong>Send Operation:</strong> Channel ၏ buffer မပြည့်မချင်း sender သည် data ပို့ပြီးနောက် block မဖြစ်ဘဲ ဆက်လက်အလုပ်လုပ်နိုင်သည်။ Buffer ပြည့်သွားမှသာ နောက်ထပ် data ပို့သည့်အခါ block ဖြစ်မည်။</li>
<li><strong>Receive Operation:</strong> Channel ၏ buffer ထဲတွင် data ရှိနေသမျှ receiver သည် block မဖြစ်ဘဲ data ကို လက်ခံနိုင်သည်။ Buffer empty ဖြစ်သွားမှသာ နောက်ထပ် data လက်ခံရန် ကြိုးစားသည့်အခါ block ဖြစ်မည်။</li>
</ul>
<pre><code class="lang-mermaid">graph TD
    subgraph &quot;Unbuffered Channel (Capacity: 0)&quot;
        Sender1[&quot;Sender&quot;] -- &quot;ch &lt;- data&quot; --&gt; Block1{Blocks until Receiver is ready}
        Receiver1[&quot;Receiver&quot;] -- &quot;&lt;- ch&quot; --&gt; Block2{Blocks until Sender is ready}
    end
    subgraph &quot;Buffered Channel (Capacity: N)&quot;
        Sender2[&quot;Sender&quot;] -- &quot;ch &lt;- data&quot; --&gt; Buffer[&quot;Buffer (Queue)&quot;]
        Buffer -- &quot;data&quot; --&gt; Receiver2[&quot;Receiver&quot;]
        Note1[&quot;Sender blocks only if buffer is full&quot;]
        Note2[&quot;Receiver blocks only if buffer is empty&quot;]
    end</code></pre>
<p><strong>Buffered Channel ဥပမာ:</strong></p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

func main() {
    // capacity 2 ရှိသော buffered channel တစ်ခု ဖန်တီးခြင်း
    ch := make(chan int, 2)

    // buffer မပြည့်သေးသောကြောင့် block မဖြစ်ပါ
    ch &lt;- 1
    ch &lt;- 2

    // အောက်ပါ line ကို uncomment လုပ်ပါက buffer ပြည့်နေသောကြောင့် deadlock ဖြစ်ပြီး panic ဖြစ်မည်
    // ch &lt;- 3 

    fmt.Println(&lt;-ch)
    fmt.Println(&lt;-ch)
}</code></pre>
<h2 id="closing-channels-and-range">Closing Channels and Range</h2>
<p>Sender က ပေးပို့စရာ data ကုန်သွားတဲ့အခါ channel ကို <code>close()</code> function သုံးပြီး ပိတ်သိမ်းနိုင်ပါတယ်။ ဒါက Receiver ကို &quot;နောက်ထပ် data မလာတော့ဘူး&quot; လို့ အသိပေးလိုက်တာပါ။</p>
<ul>
<li><strong><code>close(ch)</code></strong>: Channel ကို receiver ဘက်မှ မပိတ်ရပါ၊ sender ဘက်မှသာ ပိတ်ရပါမည်။</li>
<li><strong>Panic Risk</strong>: ပိတ်ထားပြီးသား channel ကို ထပ်ပြီး data ပို့ရင် panic ဖြစ်ပါမယ်။</li>
</ul>
<h3 id="-range-loop"><code>range</code> Loop</h3>
<p>Channel တစ်ခုမပိတ်မချင်း data များကို ဆက်တိုက်လက်ခံဖို့ <code>for range</code> loop ကို အသုံးပြုနိုင်ပါတယ်။</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

func main() {
    ch := make(chan int, 5)
    ch &lt;- 1
    ch &lt;- 2
    close(ch) // Data ပို့ပြီးကြောင်း အသိပေးသည်

    // Channel ပိတ်သွားပြီး buffer ထဲက data ကုန်တဲ့အထိ loop ပတ်မည်
    for n := range ch {
        fmt.Println(n)
    }
}</code></pre>
<h2 id="directional-channels-channels-">Directional Channels (လမ်းကြောင်းတစ်ဖက်တည်း Channels)</h2>
<p>Function parameters တွေမှာ channel ကို &quot;ပို့ဖို့သီးသန့်&quot; (Send-only) သို့မဟုတ် &quot;လက်ခံဖို့သီးသန့်&quot; (Receive-only) ဆိုပြီး ကန့်သတ်နိုင်ပါတယ်။ ဒါက Type-safety ကို ပိုမိုခိုင်မာစေပါတယ်။</p>
<ul>
<li><strong><code>chan&lt;- T</code></strong>: Send-only channel (ပို့ရန်သာ)</li>
<li><strong><code>&lt;-chan T</code></strong>: Receive-only channel (လက်ခံရန်သာ)</li>
</ul>
<pre><code class="lang-go">// ဒီ function က message ပို့ဖို့ပဲ လုပ်ခွင့်ရှိမယ် (Send-only)
func send(p chan&lt;- string) {
    p &lt;- &quot;Secret Message&quot;
}

// ဒီ function က message လက်ခံဖို့ပဲ လုပ်ခွင့်ရှိမယ် (Receive-only)
func receive(c &lt;-chan string) {
    msg := &lt;-c
    fmt.Println(msg)
}

func main() {
    ch := make(chan string)
    go send(ch)
    receive(ch)
}</code></pre>
<h2 id="-select-statement-channels-"><code>select</code> Statement ဖြင့် Channels များကို ကိုင်တွယ်ခြင်း</h2>
<p><code>select</code> statement သည် goroutine တစ်ခုကို multiple channel operations များပေါ်တွင် တစ်ပြိုင်နက်တည်း စောင့်ဆိုင်းစေနိုင်သည်။ ၎င်းသည် <code>switch</code> statement နှင့် ဆင်တူသော်လည်း channels များအတွက်သာ ဖြစ်သည်။</p>
<ul>
<li><code>select</code> သည် ၎င်း၏ <code>case</code> များထဲမှ channel တစ်ခုခု ready ဖြစ်လာသည်အထိ (send/receive လုပ်နိုင်သည်အထိ) block ဖြစ်နေမည်။</li>
<li>Channel များစွာ တစ်ပြိုင်နက်တည်း ready ဖြစ်နေပါက <code>select</code> က တစ်ခုကို ကျပန်း (randomly) ရွေးချယ်မည်။</li>
<li><code>default</code> case ကို ထည့်သွင်းထားပါက မည်သည့် channel မှ ready မဖြစ်သည့်အခါ <code>default</code> case ကို ချက်ချင်း run ပြီး <code>select</code> သည် block မဖြစ်တော့ပါ။</li>
</ul>
<pre><code class="lang-go">package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func main() {
    c1 := make(chan string)
    c2 := make(chan string)

    go func() {
        time.Sleep(1 * time.Second)
        c1 &lt;- &quot;one&quot;
    }()
    go func() {
        time.Sleep(2 * time.Second)
        c2 &lt;- &quot;two&quot;
    }()

    // c1 နှင့် c2 မှ data များ ရောက်လာသည်ကို စောင့်ဆိုင်းရန် select ကို အသုံးပြုသည်
    // loop 2 ကြိမ် ပတ်ခြင်းဖြင့် channel နှစ်ခုလုံးမှ data ကို လက်ခံမည်
    for i := 0; i &lt; 2; i++ {
        select {
        case msg1 := &lt;-c1:
            fmt.Println(&quot;received&quot;, msg1)
        case msg2 := &lt;-c2:
            fmt.Println(&quot;received&quot;, msg2)
        }
    }
}</code></pre>
<h3 id="timeout-select-">Timeout အတွက် <code>select</code> ကို အသုံးပြုခြင်း</h3>
<p><code>select</code> ကို <code>time.After</code> channel နှင့် တွဲဖက်အသုံးပြု၍ channel operation တစ်ခုအတွက် timeout သတ်မှတ်နိုင်သည်။</p>
<pre><code class="lang-go">package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func main() {
    ch := make(chan string)

    go func() {
        time.Sleep(2 * time.Second)
        ch &lt;- &quot;result&quot;
    }()

    select {
    case res := &lt;-ch:
        fmt.Println(res)
    case &lt;-time.After(1 * time.Second):
        fmt.Println(&quot;timeout: operation took too long&quot;)
    }
}</code></pre>
<h1 id="-error-handling">အခန်း ၁၄: Error Handling</h1>
<p>Go တွင် error handling သည် အခြား programming languages များစွာနှင့် ကွဲပြားပါသည်။ <code>try-catch</code> block များအစား Go သည် errors များကို function return values များအဖြစ် သာမန်တန်ဖိုးများကဲ့သို့ပင် ကိုင်တွယ်သည်။ ဤအခန်းတွင် Go ၏ error handling ပုံစံ၊ custom errors များ တည်ဆောက်ပုံ၊ နှင့် <code>panic</code>/<code>recover</code> တို့၏ အသုံးဝင်ပုံများကို လေ့လာသွားပါမည်။</p>
<h2 id="go-error-handling-error-type-">Go ၏ Error Handling ပုံစံ (<code>error</code> type)</h2>
<p>Go တွင် error ဖြစ်နိုင်ခြေရှိသော function များသည် <code>error</code> type ကို ၎င်းတို့၏ နောက်ဆုံး return value အဖြစ် ပြန်ပေးလေ့ရှိသည်။ <code>error</code> သည် အောက်ပါအတိုင်း method တစ်ခုတည်းသာပါဝင်သော built-in interface တစ်ခုဖြစ်သည်။</p>
<pre><code class="lang-go">type error interface {
    Error() string
}</code></pre>
<p>Function တစ်ခုကို ခေါ်ယူသည့်အခါ developer သည် ပြန်လာသော <code>error</code> value ကို <code>nil</code> ဟုတ်မဟုတ် စစ်ဆေးရန် တာဝန်ရှိသည်။ <code>nil</code> မဟုတ်ပါက error ဖြစ်ပွားခဲ့သည်ဟု မှတ်ယူပြီး သင့်လျော်သလို ကိုင်တွယ်ရမည်။</p>
<pre><code class="lang-go">package main

import (
    &quot;fmt&quot;
    &quot;strconv&quot;
)

func main() {
    // &quot;123&quot; သည် ကိန်းဂဏန်းဖြစ်သောကြောင့် error သည် nil ဖြစ်မည်
    num, err := strconv.Atoi(&quot;123&quot;)
    if err != nil {
        fmt.Println(&quot;An error occurred:&quot;, err)
    } else {
        fmt.Println(&quot;Converted number:&quot;, num)
    }

    // &quot;abc&quot; သည် ကိန်းဂဏန်းမဟုတ်သောကြောင့် error ဖြစ်ပွားမည်
    num, err = strconv.Atoi(&quot;abc&quot;)
    if err != nil {
        fmt.Println(&quot;An error occurred:&quot;, err)
    } else {
        fmt.Println(&quot;Converted number:&quot;, num)
    }
}</code></pre>
<h2 id="custom-errors-">Custom Errors များ တည်ဆောက်ခြင်း</h2>
<p>Go တွင် error message များကို ပိုမိုအသေးစိတ်ဖော်ပြရန် custom error များ တည်ဆောက်နိုင်သော နည်းလမ်းများစွာရှိသည်။</p>
<h3 id="1-errors-new-">1. <code>errors.New()</code></h3>
<p><code>errors</code> package မှ <code>New()</code> function ကို အသုံးပြု၍ ရိုးရှင်းသော error message string တစ်ခုကို ဖန်တီးနိုင်သည်။</p>
<pre><code class="lang-go">import &quot;errors&quot;

func checkAge(age int) error {
    if age &lt; 18 {
        return errors.New(&quot;age must be at least 18&quot;)
    }
    return nil
}</code></pre>
<h3 id="2-fmt-errorf-">2. <code>fmt.Errorf()</code></h3>
<p><code>fmt.Errorf()</code> function သည် error message ကို format လုပ်ရန်နှင့် အခြား error များကို &quot;wrap&quot; လုပ်ရန် အသုံးပြုသည်။ <code>%w</code> verb ကို အသုံးပြု၍ error တစ်ခုကို wrap လုပ်ခြင်းဖြင့် မူလ error ကို ဆက်လက်ထိန်းသိမ်းထားနိုင်ပြီး၊ <code>errors.Is()</code> သို့မဟုတ် <code>errors.As()</code> ဖြင့် ပြန်လည်စစ်ဆေးနိုင်သည်။</p>
<pre><code class="lang-go">import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func readFile() error {
    file, err := os.Open(&quot;non-existent-file.txt&quot;)
    if err != nil {
        return fmt.Errorf(&quot;failed to read file: %w&quot;, err)
    }
    defer file.Close()
    return nil
}</code></pre>
<h3 id="3-custom-error-struct">3. Custom Error Struct</h3>
<p>Error နှင့်ပတ်သက်သော အသေးစိတ်အချက်အလက်များ (e.g., status code, operation name) ကို ထည့်သွင်းလိုပါက custom struct တစ်ခုကို ဖန်တီးပြီး <code>Error()</code> method ကို implement လုပ်နိုင်သည်။</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

// AppError struct သည် error နှင့်ပတ်သက်သော အချက်အလက်များကို သိမ်းဆည်းသည်
type AppError struct {
    Operation string
    Code      int
    Message   string
}

// AppError အတွက် Error() method ကို implement လုပ်ခြင်း
func (e *AppError) Error() string {
    return fmt.Sprintf(&quot;operation &#39;%s&#39; failed with code %d: %s&quot;, e.Operation, e.Code, e.Message)
}

func runOperation() error {
    return &amp;AppError{
        Operation: &quot;user_login&quot;,
        Code:      401,
        Message:   &quot;invalid credentials&quot;,
    }
}

func main() {
    err := runOperation()
    if err != nil {
        fmt.Println(err)
    }
}</code></pre>
<h2 id="checking-wrapped-errors-errors-is-and-errors-as-">Checking Wrapped Errors (<code>errors.Is</code> and <code>errors.As</code>)</h2>
<p>Error များကို <code>fmt.Errorf</code> နှင့် <code>%w</code> အသုံးပြု၍ wrap လုပ်လိုက်သောအခါ၊ မူလ error type ကို တိုက်ရိုက်စစ်ဆေး၍မရတော့ပါ။ (ဥပမာ - <code>err == os.ErrNotExist</code> သည် false ဖြစ်သွားနိုင်သည်)။ ထိုအခါမျိုးတွင် <code>errors</code> package မှ helper function များကို အသုံးပြုရပါမည်။</p>
<h3 id="1-errors-is-">1. <code>errors.Is()</code></h3>
<p>Error တစ်ခုသည် သီးခြား error value တစ်ခု ဟုတ်မဟုတ် (wrapped လုပ်ထားသည့်တိုင်) စစ်ဆေးရန် အသုံးပြုသည်။</p>
<pre><code class="lang-go">import (
    &quot;errors&quot;
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    // Error ကို wrap လုပ်ခြင်း
    err := fmt.Errorf(&quot;file error: %w&quot;, os.ErrNotExist)

    // errors.Is ဖြင့် စစ်ဆေးခြင်း
    if errors.Is(err, os.ErrNotExist) {
        fmt.Println(&quot;File does not exist&quot;)
    }
}</code></pre>
<h3 id="2-errors-as-">2. <code>errors.As()</code></h3>
<p>Error တစ်ခုသည် သီးခြား error type တစ်ခု ဟုတ်မဟုတ် စစ်ဆေးပြီး၊ ဟုတ်မှန်ပါက ထို type သို့ cast လုပ်ရန် အသုံးပြုသည်။</p>
<pre><code class="lang-go">type MyError struct {
    Code int
}

func (e *MyError) Error() string {
    return fmt.Sprintf(&quot;error code: %d&quot;, e.Code)
}

func main() {
    err := fmt.Errorf(&quot;wrapped: %w&quot;, &amp;MyError{Code: 404})

    var myErr *MyError
    // errors.As သည် err chain ကို ရှာဖွေပြီး match ဖြစ်ပါက myErr ထဲသို့ တန်ဖိုးထည့်ပေးသည်
    if errors.As(err, &amp;myErr) {
        fmt.Println(&quot;It is MyError with code:&quot;, myErr.Code)
    }
}</code></pre>
<h2 id="-panic-recover-"><code>panic</code> နှင့် <code>recover</code></h2>
<p><code>panic</code> နှင့် <code>recover</code> သည် Go ၏ error handling mechanism ၏ အစိတ်အပိုင်းတစ်ခုဖြစ်သော်လည်း၊ ၎င်းတို့ကို နေ့စဉ် error handling အတွက် <strong>အသုံးမပြုသင့်ပါ</strong>။</p>
<ul>
<li><p><strong><code>panic</code>:</strong> Program တွင် ဆက်လက်လုပ်ဆောင်၍မရသော၊ မမျှော်လင့်ထားသည့် အမှားအယွင်းကြီးများ (e.g., nil pointer dereference, index out of bounds) ဖြစ်ပွားသည့်အခါ <code>panic</code> ကို အသုံးပြုသည်။ <code>panic</code> ဖြစ်ပွားပါက program ၏ normal execution ရပ်တန့်သွားပြီး goroutine stack တစ်လျှောက်ရှိ deferred functions များကို run ပြီးနောက် program သည် crash ဖြစ်သွားသည်။</p>
</li>
<li><p><strong><code>recover</code>:</strong> <code>panic</code> ဖြစ်ပွားနေသော goroutine ၏ control ကို ပြန်လည်ရယူရန် <code>recover</code> ကို အသုံးပြုသည်။ <code>recover</code> ကို <code>defer</code> statement အတွင်းမှာသာ ခေါ်ယူမှသာ အလုပ်လုပ်သည်။ ၎င်းသည် <code>panic</code> ၏ value ကို return ပြန်ပေးပြီး program ကို ဆက်လက် run စေနိုင်သည်။</p>
</li>
</ul>
<p><strong>အသုံးဝင်ပုံ:</strong> Web server တစ်ခုတွင် request တစ်ခုကို handle လုပ်သော goroutine <code>panic</code> ဖြစ်သွားပါက server တစ်ခုလုံး crash မဖြစ်စေရန် <code>recover</code> ဖြင့် ဖမ်းယူပြီး၊ ထို request အတွက် 500 Internal Server Error response ပြန်ပေးကာ အခြား requests များကို ဆက်လက်ဝန်ဆောင်မှုပေးနိုင်သည်။</p>
<pre><code class="lang-mermaid">graph TD
    A[Function Call] --&gt; B{Normal Execution}
    B --&gt; C{Something causes panic!}
    C -- &quot;Panic Occurs&quot; --&gt; D{Run Deferred Functions}

    subgraph &quot;Deferred Function&quot;
        E[&quot;defer func() { ... }&quot;] --&gt; F{&quot;Call recover()&quot;}
    end

    D --&gt; E
    F -- &quot;Recovers from panic&quot; --&gt; G{Handle error, log, etc.}
    G --&gt; H[&quot;Resume Normal Execution (after function returns)&quot;]

    C -- &quot;If not recovered&quot; --&gt; I[Program Crashes]</code></pre>
<p><strong>ဥပမာ:</strong></p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

func handlePanic() {
    // recover() ကို defer function အတွင်းမှာ ခေါ်သည်
    if r := recover(); r != nil {
        fmt.Println(&quot;Recovered from panic:&quot;, r)
    }
}

func causePanic() {
    defer handlePanic()

    fmt.Println(&quot;About to panic...&quot;)
    // nil slice ကို access လုပ်ရန် ကြိုးစားခြင်းဖြင့် panic ဖြစ်စေသည်
    var arr []int
    fmt.Println(arr[0]) 

    fmt.Println(&quot;This line will not be reached.&quot;)
}

func main() {
    causePanic()
    fmt.Println(&quot;Program continues to run after panic was recovered.&quot;)
}</code></pre>
<h1 id="-standard-library-packages">အခန်း ၁၅: အသုံးများသော Standard Library Packages</h1>
<p>Go ၏ အကြီးမားဆုံး အားသာချက်တစ်ခုမှာ အလွန်စွမ်းဆောင်ရည်မြင့်မားပြီး ကျယ်ပြန့်သော standard library ပါဝင်ခြင်းဖြစ်သည်။ ယခုအခန်းတွင် နေ့စဉ် programming ပြုလုပ်ရာတွင် အသုံးအများဆုံးဖြစ်သော standard library packages အချို့၏ အခြေခံအသုံးပြုပုံကို လေ့လာသွားပါမည်။</p>
<h2 id="-fmt-formatted-i-o-"><code>fmt</code> (Formatted I/O)</h2>
<p><code>fmt</code> package သည် console သို့ data များ print ထုတ်ခြင်း (output) နှင့် user ထံမှ data များ ဖတ်ရှုခြင်း (input) ကဲ့သို့သော formatted I/O (Input/Output) လုပ်ဆောင်ချက်များကို ကိုင်တွယ်သည်။</p>
<ul>
<li><code>fmt.Println()</code>: Arguments များကို space ခြား၍ print ထုတ်ပြီးနောက် new line တစ်ကြောင်းဆင်းပေးသည်။</li>
<li><code>fmt.Printf()</code>: Format specifiers (<code>%s</code>, <code>%d</code>, <code>%v</code> etc.) များကို အသုံးပြု၍ string ကို format လုပ်ပြီး print ထုတ်သည်။</li>
<li><code>fmt.Sprintf()</code>: <code>Printf</code> ကဲ့သို့ပင်ဖြစ်သော်လည်း console တွင် print မထုတ်ဘဲ formatted string ကို return ပြန်ပေးသည်။</li>
</ul>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

func main() {
    name := &quot;Go&quot;
    version := 1.18

    fmt.Println(&quot;Language:&quot;, name, &quot;Version:&quot;, version)

    // %s for string, %f for float
    fmt.Printf(&quot;Language: %s, Version: %.2f\n&quot;, name, version)

    // %v for any value (default format)
    fmt.Printf(&quot;Value: %v, Type: %T\n&quot;, version, version)
}</code></pre>
<h2 id="-os-operating-system-interactions-"><code>os</code> (Operating System Interactions)</h2>
<p><code>os</code> package သည် operating system နှင့် တိုက်ရိုက်ဆက်နွယ်သော လုပ်ဆောင်ချက်များ (e.g., files, command-line arguments) ကို ကိုင်တွယ်ရန် platform-independent interface တစ်ခုကို ပေးသည်။</p>
<ul>
<li><code>os.Args</code>: Program ကို run သည့်အခါ ပေးလိုက်သော command-line arguments များကို string slice (<code>[]string</code>) အဖြစ် ရရှိသည်။ <code>os.Args[0]</code> သည် program ၏ အမည်ဖြစ်သည်။</li>
<li><code>os.ReadFile(name string)</code>: File တစ်ခုလုံးကို ဖတ်ပြီး byte slice (<code>[]byte</code>) အဖြစ် return ပြန်ပေးသည်။</li>
<li><code>os.WriteFile(name string, data []byte, perm fs.FileMode)</code>: <code>data</code> ကို file ထဲသို့ ရေးသားသည်။</li>
</ul>
<pre><code class="lang-go">package main

import (
    &quot;fmt&quot;
    &quot;log&quot;
    &quot;os&quot;
)

func main() {
    // File ထဲသို့ ရေးသားခြင်း
    data := []byte(&quot;Hello from Go standard library!&quot;)
    err := os.WriteFile(&quot;test.txt&quot;, data, 0644)
    if err != nil {
        log.Fatal(err)
    }
    fmt.Println(&quot;Successfully wrote to test.txt&quot;)

    // File မှ ဖတ်ရှုခြင်း
    readData, err := os.ReadFile(&quot;test.txt&quot;)
    if err != nil {
        log.Fatal(err)
    }
    fmt.Println(&quot;Read from test.txt:&quot;, string(readData))
}</code></pre>
<h2 id="-embed-embedding-files-"><code>embed</code> (Embedding Files)</h2>
<p>Go 1.16 မှစတင်၍ <code>embed</code> package ကို အသုံးပြုကာ static file များ (images, HTML, config files) ကို Go binary ထဲသို့ တိုက်ရိုက်ထည့်သွင်း (embed) လာနိုင်ပြီဖြစ်သည်။ ၎င်းသည် single-binary application များ deploy လုပ်ရာတွင် အလွန်အသုံးဝင်သည်။</p>
<p><code>//go:embed</code> directive ကို အသုံးပြုရသည်။</p>
<pre><code class="lang-go">package main

import (
    &quot;embed&quot;
    &quot;fmt&quot;
)

//go:embed hello.txt
var content string

//go:embed config.json
var config []byte

//go:embed static/*
var staticFiles embed.FS

func main() {
    // String အနေဖြင့် ဖတ်ခြင်း
    fmt.Println(&quot;Content of hello.txt:&quot;, content)

    // Byte slice အနေဖြင့် ဖတ်ခြင်း
    fmt.Println(&quot;Config size:&quot;, len(config), &quot;bytes&quot;)

    // File System အနေဖြင့် ဖတ်ခြင်း
    data, _ := staticFiles.ReadFile(&quot;static/index.html&quot;)
    fmt.Println(&quot;Index HTML:&quot;, string(data))
}</code></pre>
<blockquote>
<p><strong>သတိပြုရန်:</strong> <code>//</code> နှင့် <code>go:embed</code> ကြားတွင် space မရှိရပါ (ဥပမာ <code>// go:embed</code> ဟု မရေးရပါ)။ ထို့ပြင် directive နှင့် variable ကြားတွင် empty line မရှိရပါ။</p>
</blockquote>
<h2 id="-log-package"><code>log</code> Package</h2>
<p><code>log</code> package သည် program ၏ status message များနှင့် error များကို timestamp နှင့်တကွ မှတ်တမ်းတင်ရန် (print ထုတ်ရန်) အသုံးပြုသည်။ Production code များတွင် <code>fmt.Println</code> ထက် <code>log</code> package ကို ပိုမိုအသုံးပြုသင့်သည်။</p>
<ul>
<li><code>log.Println()</code>: Standard output သို့ timestamp နှင့်တကွ စာသားကို print ထုတ်သည်။</li>
<li><code>log.Printf()</code>: Format specifier များကို အသုံးပြု၍ print ထုတ်သည်။</li>
<li><code>log.Fatal()</code>: Error message ကို print ထုတ်ပြီးနောက် program ကို ချက်ချင်းရပ်တန့်သည် (<code>os.Exit(1)</code> ကို ခေါ်သည်)။</li>
</ul>
<pre><code class="lang-go">package main

import (
    &quot;log&quot;
    &quot;os&quot;
)

func main() {
    file, err := os.Open(&quot;config.txt&quot;)
    if err != nil {
        // Error ဖြစ်ပါက log ထုတ်ပြီး program ကို ရပ်တန့်မည်
        log.Fatal(&quot;Error opening file: &quot;, err)
    }
    log.Println(&quot;Successfully opened file:&quot;, file.Name())
}</code></pre>
<h2 id="-time-package"><code>time</code> Package</h2>
<p><code>time</code> package သည် အချိန်နှင့်ပတ်သက်သော တွက်ချက်မှုများ၊ formatting နှင့် waiting (sleep) တို့ကို ကိုင်တွယ်သည်။</p>
<ul>
<li><code>time.Now()</code>: လက်ရှိအချိန်ကို ရယူသည်။</li>
<li><code>time.Sleep(duration)</code>: Program ကို သတ်မှတ်ထားသော ကြာချိန်တစ်ခုအထိ ခေတ္တရပ်နားသည်။</li>
<li><code>time.Parse(layout, value)</code>: String မှ Time object သို့ ပြောင်းလဲသည်။</li>
</ul>
<pre><code class="lang-go">package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func main() {
    start := time.Now()
    fmt.Println(&quot;Start time:&quot;, start.Format(&quot;2006-01-02 15:04:05&quot;))

    // 2 စက္ကန့် စောင့်မည်
    time.Sleep(2 * time.Second)

    elapsed := time.Since(start)
    fmt.Println(&quot;Program took:&quot;, elapsed)
}</code></pre>
<h2 id="-strings-and-strconv-"><code>strings</code> and <code>strconv</code></h2>
<ul>
<li><strong><code>strings</code> package:</strong> String များကို ကိုင်တွယ်ရန် အသုံးဝင်သော functions များစွာ ပါဝင်သည်။</li>
<li><strong><code>strconv</code> package:</strong> String နှင့် အခြား data types (e.g., <code>int</code>, <code>bool</code>) များအကြား အပြန်အလှန် ပြောင်းလဲရန် (conversion) အသုံးပြုသည်။</li>
</ul>
<pre><code class="lang-go">package main

import (
    &quot;fmt&quot;
    &quot;strconv&quot;
    &quot;strings&quot;
)

func main() {
    // strings package
    s := &quot;Hello, World, Go&quot;
    fmt.Println(&quot;Contains &#39;World&#39;:&quot;, strings.Contains(s, &quot;World&quot;))
    fmt.Println(&quot;To Upper:&quot;, strings.ToUpper(s))
    fmt.Println(&quot;Split by &#39;,&#39;:&quot;, strings.Split(s, &quot;,&quot;))

    // strconv package
    numStr := &quot;123&quot;
    num, err := strconv.Atoi(numStr) // Atoi = ASCII to Integer
    if err != nil {
        fmt.Println(&quot;Error converting string to int:&quot;, err)
    } else {
        fmt.Println(&quot;Converted number:&quot;, num+1)
    }

    numToConvert := 456
    str := strconv.Itoa(numToConvert) // Itoa = Integer to ASCII
    fmt.Println(&quot;Converted string:&quot;, str)
}</code></pre>
<h2 id="-encoding-json-json-data-"><code>encoding/json</code> (JSON Data ကိုင်တွယ်ခြင်း)</h2>
<p><code>encoding/json</code> package သည် Go data structures (structs, maps) နှင့် JSON data format အကြား အပြန်အလှန် ပြောင်းလဲရန် အသုံးပြုသည်။</p>
<ul>
<li><strong>Marshalling:</strong> Go struct ကို JSON string (byte slice) အဖြစ်သို့ ပြောင်းလဲခြင်း။</li>
<li><strong>Unmarshalling:</strong> JSON string (byte slice) ကို Go struct အဖြစ်သို့ ပြောင်းလဲခြင်း။</li>
</ul>
<pre><code class="lang-mermaid">graph TD
    A[Go Struct] -- &quot;json.Marshal()&quot; --&gt; B[&quot;JSON String (bytes)&quot;]
    B -- &quot;json.Unmarshal()&quot; --&gt; A</code></pre>
<p><strong>ဥပမာ:</strong></p>
<pre><code class="lang-go">package main

import (
    &quot;encoding/json&quot;
    &quot;fmt&quot;
    &quot;log&quot;
)

// Struct field များကို JSON key များနှင့် mapping လုပ်ရန် struct tags များကို အသုံးပြုသည်
type User struct {
    ID       int    `json:&quot;id&quot;`
    Name     string `json:&quot;name&quot;`
    Email    string `json:&quot;email&quot;`
    Password string `json:&quot;-&quot;` // `json:&quot;-&quot;` tag သည် ဤ field ကို JSON တွင် မပါဝင်စေရန် ဖြစ်သည်
}

func main() {
    // --- Marshalling (Go struct to JSON) ---
    user := User{ID: 1, Name: &quot;Aung Aung&quot;, Email: &quot;aung@example.com&quot;, Password: &quot;secret-password&quot;}
    jsonData, err := json.MarshalIndent(user, &quot;&quot;, &quot;  &quot;) // MarshalIndent for pretty-printing
    if err != nil {
        log.Fatal(err) // panic အစား log.Fatal ကို အသုံးပြုခြင်းက ပိုကောင်းသည်
    }
    fmt.Println(&quot;Marshalled JSON:\n&quot;, string(jsonData))

    // --- Unmarshalling (JSON to Go struct) ---
    jsonString := `{&quot;id&quot;: 2, &quot;name&quot;: &quot;Ma Ma&quot;, &quot;email&quot;: &quot;ma@example.com&quot;}`
    var anotherUser User
    err = json.Unmarshal([]byte(jsonString), &amp;anotherUser)
    if err != nil {
        log.Fatal(err)
    }
    fmt.Println(&quot;\nUnmarshalled User:&quot;, anotherUser)
    fmt.Println(&quot;Unmarshalled User&#39;s Name:&quot;, anotherUser.Name)
}</code></pre>
<h2 id="-net-http-web-server-"><code>net/http</code> (Web Server တည်ဆောက်ခြင်း)</h2>
<p><code>net/http</code> package သည် production-ready HTTP client နှင့် server များကို အလွယ်တကူ တည်ဆောက်နိုင်ရန် လိုအပ်သော tools များအားလုံးကို ပေးသည်။</p>
<pre><code class="lang-mermaid">graph LR
    Client[&quot;User&#39;s Browser&quot;] -- &quot;HTTP Request (e.g., GET /hello)&quot; --&gt; Server[&quot;Go HTTP Server&quot;]
    Server -- &quot;invokes&quot; --&gt; Handler[&quot;Handler Function for /hello&quot;]
    Handler -- &quot;writes response&quot; --&gt; Response[&quot;HTTP Response (e.g., &#39;Hello, World!&#39;)&quot;]
    Response -- &quot;sends back to&quot; --&gt; Client</code></pre>
<p><strong>ဥပမာ: Simple Web Server</strong></p>
<pre><code class="lang-go">package main

import (
    &quot;fmt&quot;
    &quot;log&quot;
    &quot;net/http&quot;
)

// handler function သည် http.ResponseWriter နှင့် *http.Request ကို parameter အဖြစ် လက်ခံသည်
func helloHandler(w http.ResponseWriter, r *http.Request) {
    // ResponseWriter သို့ data ရေးသားခြင်းဖြင့် client သို့ response ပြန်ပေးသည်
    fmt.Fprintf(w, &quot;Hello, you&#39;ve requested: %s\n&quot;, r.URL.Path)
}

func main() {
    // URL path &quot;/hello&quot; အတွက် helloHandler function ကို register လုပ်သည်
    http.HandleFunc(&quot;/hello&quot;, helloHandler)

    fmt.Println(&quot;Starting server on port 8080...&quot;)
    // Port 8080 တွင် server ကို စတင် run ပြီး incoming requests များကို စောင့်ဆိုင်းသည်
    // ဤ function သည် error return ပြန်မှသာ ပြီးဆုံးမည် (e.g., port is already in use)
    err := http.ListenAndServe(&quot;:8080&quot;, nil)
    if err != nil {
        log.Fatal(err)
    }
}</code></pre>
<p>ဤ program ကို run ပြီး web browser တွင် <code>http://localhost:8080/hello</code> သို့ သွားရောက်ကြည့်ရှုပါက &quot;Hello, you&#39;ve requested: /hello&quot; ဟူသော စာသားကို မြင်တွေ့ရမည်ဖြစ်သည်။</p>
<h1 id="-testing-in-go">အခန်း ၁၆: Testing in Go</h1>
<p>Software development တွင် testing သည် code ၏ အရည်အသွေး၊ မှန်ကန်မှု၊ နှင့် ယုံကြည်စိတ်ချရမှုကို အာမခံရန်အတွက် မရှိမဖြစ်လိုအပ်သော အစိတ်အပိုင်းတစ်ခုဖြစ်သည်။ Go သည် <code>testing</code> package ကို standard library တွင် တပါတည်း ထည့်သွင်းပေးထားပြီး၊ unit tests နှင့် performance benchmark tests များကို ရိုးရှင်းလွယ်ကူစွာ ရေးသားနိုင်ရန် အားပေးသည်။</p>
<h2 id="-testing-package-testing-conventions"><code>testing</code> package နှင့် Testing Conventions</h2>
<p>Go တွင် test code များကို ရေးသားရန်အတွက် လိုက်နာရမည့် conventions အချို့ရှိသည်။</p>
<ul>
<li><strong>File Naming:</strong> Test code များပါဝင်သော file ၏ အမည်သည် <code>_test.go</code> ဖြင့် အဆုံးသတ်ရမည် (e.g., <code>calculator_test.go</code>)။</li>
<li><strong>Test Function Signature:</strong> Test function တိုင်းသည် <code>Test</code> ဖြင့် စတင်ရမည်ဖြစ်ပြီး <code>*testing.T</code> type parameter တစ်ခုတည်းသာ လက်ခံရမည် (e.g., <code>func TestAdd(t *testing.T)</code>)။</li>
<li><strong><code>*testing.T</code> Type:</strong> ဤ type သည် test ၏ state ကို စီမံခန့်ခွဲရန်နှင့် test failure များကို report လုပ်ရန် <code>t.Errorf()</code>, <code>t.Fatalf()</code>, <code>t.Log()</code> ကဲ့သို့သော methods များကို ပေးသည်။</li>
<li><strong>Running Tests:</strong> Terminal တွင် <code>go test</code> command ကို အသုံးပြု၍ package တစ်ခုအတွင်းရှိ test များအားလုံးကို run နိုင်ပါသည်။</li>
</ul>
<h2 id="unit-tests-">Unit Tests ရေးသားခြင်း</h2>
<p>Unit test ဆိုသည်မှာ program ၏ အစိတ်အပိုင်းငယ်တစ်ခု (function သို့မဟုတ် method တစ်ခု) ကို သီးခြားစမ်းသပ်ခြင်းဖြစ်သည်။</p>
<p><strong>ဥပမာ:</strong> <code>calculator</code> package ထဲတွင် <code>Add</code> function တစ်ခုရှိသည်ဆိုပါစို့။</p>
<p><strong><code>calculator.go</code></strong></p>
<pre><code class="lang-go">package calculator

func Add(a, b int) int {
    return a + b
}</code></pre>
<p><strong><code>calculator_test.go</code></strong></p>
<pre><code class="lang-go">package calculator

import &quot;testing&quot;

func TestAdd(t *testing.T) {
    result := Add(2, 3)
    expected := 5

    if result != expected {
        // Test ကျရှုံးပါက error message ကို print ထုတ်ပြီး test ကို ဆက်လက် run နေမည်
        t.Errorf(&quot;Add(2, 3) = %d; want %d&quot;, result, expected)
    }
}</code></pre>
<h2 id="table-driven-tests">Table-Driven Tests</h2>
<p>Function တစ်ခုကို input အမျိုးမျိုးဖြင့် စမ်းသပ်လိုသည့်အခါ test case တစ်ခုချင်းစီအတွက် test function တစ်ခုစီ ရေးသားခြင်းထက်၊ <strong>Table-driven test</strong> ပုံစံကို အသုံးပြုခြင်းက ပိုမိုရှင်းလင်းပြီး ထိရောက်မှုရှိသည်။ ဤပုံစံတွင် test cases များကို slice of structs အဖြစ် ကြိုတင်သတ်မှတ်ပြီး loop ပတ်၍ တစ်ခုချင်း စမ်းသပ်သည်။</p>
<pre><code class="lang-mermaid">graph TD
    A[&quot;Test Function (e.g., TestAdd)&quot;] --&gt; B[&quot;Define Slice of Test Cases&lt;br/&gt;(structs)&quot;]
    B --&gt; C{Loop through each test case}
    C -- &quot;Run as a sub-test&quot; --&gt; D[&quot;t.Run(test.name, ...)&quot;]
    D --&gt; E{Execute logic with test inputs}
    E --&gt; F{Compare result with expected output}
    F -- &quot;If not equal&quot; --&gt; G[&quot;Report Error: t.Errorf()&quot;]
    F -- &quot;If equal&quot; --&gt; H[Pass]
    C -- &quot;Next test case&quot; --&gt; D</code></pre>
<p><strong>ဥပမာ:</strong></p>
<pre><code class="lang-go">package calculator

import &quot;testing&quot;

func TestAddTableDriven(t *testing.T) {
    // Test cases များကို struct slice အဖြစ် သတ်မှတ်ခြင်း
    testCases := []struct {
        name     string // test case ၏ အမည်
        a, b     int    // inputs
        expected int    // expected output
    }{
        {&quot;positive numbers&quot;, 2, 3, 5},
        {&quot;negative numbers&quot;, -2, -3, -5},
        {&quot;mixed numbers&quot;, -2, 3, 1},
        {&quot;zero value&quot;, 0, 0, 0},
    }

    // Test case တစ်ခုချင်းစီကို loop ပတ်၍ run ခြင်း
    for _, tc := range testCases {
        // t.Run() ကို အသုံးပြု၍ sub-test တစ်ခုအဖြစ် run ခြင်းဖြင့် test output များကို ပိုမိုရှင်းလင်းစေသည်
        t.Run(tc.name, func(t *testing.T) {
            result := Add(tc.a, tc.b)
            if result != tc.expected {
                t.Errorf(&quot;Add(%d, %d) = %d; want %d&quot;, tc.a, tc.b, result, tc.expected)
            }
        })
    }
}</code></pre>
<h2 id="test-coverage">Test Coverage</h2>
<p>Test များရေးသားပြီးပါက၊ ထို test များသည် code ၏ မည်မျှရာခိုင်နှုန်းကို စမ်းသပ်ပေးနိုင်သည် (cover ဖြစ်သည်) ကို သိရှိရန် အရေးကြီးသည်။ Go တွင် coverage ကို တိုင်းတာရန် built-in support ပါရှိသည်။</p>
<p><code>go test -cover</code> command ကို အသုံးပြု၍ coverage ကို ကြည့်ရှုနိုင်သည်။</p>
<pre><code class="lang-sh">$ go test -cover
PASS
coverage: 80.0% of statements
ok      myproject/calculator    0.005s</code></pre>
<p>အသေးစိတ် report လိုချင်ပါက <code>-coverprofile</code> flag ကို အသုံးပြု၍ file ထုတ်နိုင်ပြီး၊ <code>go tool cover</code> ဖြင့် browser တွင် ကြည့်ရှုနိုင်သည်။</p>
<pre><code class="lang-sh">go test -coverprofile=coverage.out
go tool cover -html=coverage.out</code></pre>
<h2 id="testmain-setup-and-teardown-">TestMain (Setup and Teardown)</h2>
<p>Package တစ်ခုလုံးအတွက် initialization (setup) သို့မဟုတ် cleanup (teardown) လုပ်ရန် လိုအပ်ပါက (ဥပမာ - Database connection ဖွင့်ခြင်း/ပိတ်ခြင်း)၊ <code>TestMain</code> function ကို အသုံးပြုနိုင်သည်။</p>
<p><strong>စည်းမျဉ်း:</strong> <code>TestMain</code> သည် <code>*testing.M</code> ကို parameter အဖြစ်လက်ခံပြီး၊ <code>m.Run()</code> ကို ခေါ်ယူမှသာ အခြား test များ အလုပ်လုပ်မည်ဖြစ်သည်။ <code>os.Exit()</code> ဖြင့် exit code ကို ပြန်ပေးရမည်။</p>
<pre><code class="lang-go">func TestMain(m *testing.M) {
    // 1. Setup (e.g., Database connect)
    fmt.Println(&quot;Setting up resources...&quot;)

    // 2. Run Tests
    code := m.Run()

    // 3. Teardown (e.g., Database close)
    fmt.Println(&quot;Cleaning up resources...&quot;)

    // 4. Exit with code
    os.Exit(code)
}</code></pre>
<h2 id="benchmarking">Benchmarking</h2>
<p>Benchmarking ဆိုသည်မှာ code ၏ performance (အထူးသဖြင့် speed) ကို တိုင်းတာခြင်းဖြစ်သည်။ Go တွင် benchmark tests များကို <code>testing</code> package ဖြင့် အလွယ်တကူ ရေးသားနိုင်သည်။</p>
<ul>
<li><strong>Benchmark Function Signature:</strong> Benchmark function တိုင်းသည် <code>Benchmark</code> ဖြင့် စတင်ရမည်ဖြစ်ပြီး <code>*testing.B</code> type parameter တစ်ခုတည်းသာ လက်ခံရမည် (e.g., <code>func BenchmarkAdd(b *testing.B)</code>)။</li>
<li><strong><code>b.N</code>:</strong> <code>testing.B</code> တွင် <code>N</code> ဟူသော field တစ်ခုပါဝင်သည်။ Benchmark function အတွင်းရှိ loop ကို <code>b.N</code> အကြိမ်အထိ run ရန်ဖြစ်သည်။ Go test runner သည် တည်ငြိမ်သော performance တိုင်းတာမှုတစ်ခုရရှိရန် <code>N</code> ၏တန်ဖိုးကို အလိုအလျောက် ချိန်ညှိပေးသည်။</li>
<li><strong>Running Benchmarks:</strong> Benchmarks များကို run ရန် <code>go test -bench=.</code> command ကို အသုံးပြုရသည်။ (<code>.</code> သည် package အတွင်းရှိ benchmark အားလုံးကို run ရန် ညွှန်ပြသည်)။</li>
</ul>
<p><strong>ဥပမာ:</strong></p>
<pre><code class="lang-go">package calculator

import &quot;testing&quot;

func BenchmarkAdd(b *testing.B) {
    // b.N သည် Go test runner မှ သတ်မှတ်ပေးသော loop အကြိမ်အရေအတွက်ဖြစ်သည်
    for i := 0; i &lt; b.N; i++ {
        Add(100, 200)
    }
}</code></pre>
<p><strong>Benchmark Result ဥပမာ:</strong></p>
<pre><code class="lang-sh">$ go test -bench=.
goos: darwin
goarch: amd64
pkg: myproject/calculator
cpu: Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz
BenchmarkAdd-12         1000000000               0.2831 ns/op
PASS
ok      myproject/calculator    0.358s</code></pre>
<ul>
<li><code>BenchmarkAdd-12</code>: Benchmark function အမည်နှင့် အသုံးပြုခဲ့သော CPU core အရေအတွက်။</li>
<li><code>1000000000</code>: <code>b.N</code> ၏ တန်ဖိုး (loop ကို အကြိမ်ပေါင်း ဘီလီယံ ၁ ထောင် run ခဲ့သည်)။</li>
<li><code>0.2831 ns/op</code>: Operation တစ်ခု (loop တစ်ခါပတ်ခြင်း) အတွက် ပျမ်းမျှကြာချိန် (nanoseconds)။</li>
</ul>
<h2 id="fuzzing-go-1-18-">Fuzzing (Go 1.18+)</h2>
<p><strong>Fuzzing</strong> သည် automated testing technique တစ်ခုဖြစ်ပြီး၊ မမျှော်လင့်ထားသော input များကို random ထည့်သွင်း၍ program ၏ stability နှင့် security ကို စစ်ဆေးခြင်းဖြစ်သည်။ Go 1.18 တွင် Fuzzing ကို <code>testing</code> package တွင် native support ပေးထားသည်။</p>
<ul>
<li><strong>Fuzz Function Signature:</strong> <code>Fuzz</code> ဖြင့် စတင်ရမည်ဖြစ်ပြီး <code>*testing.F</code> ကို လက်ခံရမည် (e.g., <code>func FuzzReverse(f *testing.F)</code>)။</li>
<li><strong>Seed Corpus:</strong> <code>f.Add()</code> ကို အသုံးပြု၍ မှန်ကန်သော sample input များကို ထည့်သွင်းပေးရသည်။</li>
<li><strong>Fuzz Target:</strong> <code>f.Fuzz()</code> function အတွင်းတွင် random input များကို လက်ခံမည့် function ကို ရေးသားရသည်။</li>
</ul>
<p><strong>ဥပမာ:</strong></p>
<pre><code class="lang-go">package calculator

import (
    &quot;testing&quot;
    &quot;unicode/utf8&quot;
)

func Reverse(s string) string {
    // ... implementation ...
    return &quot;&quot; // placeholder
}

func FuzzReverse(f *testing.F) {
    // 1. Seed Corpus (Sample inputs)
    f.Add(&quot;Hello&quot;)
    f.Add(&quot;12345&quot;)

    // 2. Fuzz Target
    f.Fuzz(func(t *testing.T, orig string) {
        rev := Reverse(orig)
        doubleRev := Reverse(rev)

        // Property: Reverse နှစ်ခါလုပ်ရင် မူလအတိုင်း ပြန်ဖြစ်ရမည်
        if orig != doubleRev {
            t.Errorf(&quot;Before: %q, after: %q, double: %q&quot;, orig, rev, doubleRev)
        }

        // Property: UTF-8 valid ဖြစ်ရမည်
        if utf8.ValidString(orig) &amp;&amp; !utf8.ValidString(rev) {
            t.Errorf(&quot;Reverse produced invalid UTF-8 string %q&quot;, rev)
        }
    })
}</code></pre>
<p>Fuzzing run ရန်:</p>
<pre><code class="lang-sh">go test -fuzz=Fuzz</code></pre>
<h1 id="-project-simple-rest-api-">အခန်း ၁၇: Project - Simple REST API တည်ဆောက်ခြင်း (အပိုင်း ၁)</h1>
<p>ယခုအခန်းမှစ၍ ယခင်လေ့လာခဲ့သော Go ၏ concepts များကို ပေါင်းစပ်ပြီး လက်တွေ့ project တစ်ခုကို စတင်တည်ဆောက်ပါမည်။ ကျွန်ုပ်တို့ တည်ဆောက်မည့် project မှာ To-Do List တစ်ခုကို စီမံခန့်ခွဲနိုင်သော ရိုးရှင်းသည့် REST API တစ်ခုဖြစ်သည်။</p>
<p>ဤအပိုင်း (Part 1) တွင် project အတွက် planning ပြုလုပ်ခြင်း၊ data structure များ သတ်မှတ်ခြင်း၊ နှင့် standard <code>net/http</code> package ကို အသုံးပြု၍ အခြေခံ routing နှင့် handlers များ ရေးသားခြင်းတို့ကို လေ့လာသွားပါမည်။</p>
<h2 id="project-planning">Project Planning</h2>
<p>Project တစ်ခုကို မစတင်မီ ဘာတွေလုပ်ဆောင်မည်ကို ကြိုတင် plan လုပ်ခြင်းသည် အလွန်အရေးကြီးပါသည်။</p>
<p><strong>1. Project ၏ ရည်ရွယ်ချက်:</strong></p>
<ul>
<li>To-Do tasks များကို စီမံခန့်ခွဲရန်အတွက် RESTful API တစ်ခု တည်ဆောက်ရန်။</li>
</ul>
<p><strong>2. အဓိက Features (Part 1):</strong></p>
<ul>
<li>Task အားလုံးကို list အဖြစ် ကြည့်ရှုနိုင်ခြင်း။</li>
<li>Task အသစ်တစ်ခု ဖန်တီးနိုင်ခြင်း။</li>
</ul>
<p><strong>3. Data Structure:</strong></p>
<ul>
<li>Task တစ်ခုကို ဖော်ပြရန်အတွက် <code>Task</code> struct ကို အောက်ပါအတိုင်း သတ်မှတ်ပါမည်။</li>
</ul>
<pre><code class="lang-go">type Task struct {
    ID        int    `json:&quot;id&quot;`
    Title     string `json:&quot;title&quot;`
    Completed bool   `json:&quot;completed&quot;`
}</code></pre>
<p><strong>4. API Endpoints:</strong></p>
<ul>
<li>ကျွန်ုပ်တို့၏ API တွင် အောက်ပါ endpoints များ ပါဝင်မည်ဖြစ်သည်။</li>
</ul>
<pre><code class="lang-mermaid">graph TD
    subgraph &quot;To-Do List API (Part 1)&quot;
        A[&quot;GET /tasks&quot;] --&gt; B[&quot;Task အားလုံးကို JSON array အဖြစ် ပြန်ပေးမည်&quot;]
        C[&quot;POST /tasks&quot;] --&gt; D[&quot;Request body မှ JSON data ကို အသုံးပြု၍&lt;br/&gt;Task အသစ်တစ်ခု ဖန်တီးပြီး&lt;br/&gt;ထို task ကို JSON အဖြစ် ပြန်ပေးမည်&quot;]
    end</code></pre>
<h2 id="project-structure-standard-layout-">Project Structure (Standard Layout)</h2>
<p>Go community တွင် တွင်ကျယ်စွာအသုံးပြုသော project structure ပုံစံတစ်ခုရှိသည်။ ဤ project သည် သေးငယ်သော်လည်း၊ လုပ်ငန်းခွင်သုံး project ကြီးများအတွက် အဆင်သင့်ဖြစ်စေရန် standard layout ကို မိတ်ဆက်ပေးချင်ပါသည်။</p>
<pre><code>my-todo-app/
├── cmd/
│   └── api/
│       └── main.go       // Entry point of the application
├── internal/             // Private application code
│   ├── handlers/         // HTTP handlers
│   └── models/           // Data structures
└── go.mod                // Module definition</code></pre>
<ul>
<li><strong><code>cmd/</code>:</strong> Application ၏ main entry point များထားရှိရာနေရာ (e.g., <code>cmd/api/main.go</code>).</li>
<li><strong><code>internal/</code>:</strong> Library အနေဖြင့် import လုပ်၍ မရစေချင်သော private code များ (handlers, business logic) ထားရှိရာ။</li>
<li><strong><code>pkg/</code>:</strong> အခြား project များမှပါ အသုံးပြုနိုင်သော public library code များ (ဤ project တွင် လောလောဆယ် မပါဝင်ပါ)။</li>
</ul>
<p>သို့သော် ယခုအပိုင်း (Part 1) တွင် လေ့လာရလွယ်ကူစေရန် code များကို <code>main.go</code> တစ်ခုတည်းတွင် စုစည်းရေးသားပါမည်။ နောက်ပိုင်းအပိုင်းများတွင် code များကို အထက်ပါ structure အတိုင်း refactor လုပ်သွားပါမည်။</p>
<h2 id="http-handlers-">HTTP Handlers များ ရေးသားခြင်း</h2>
<p>HTTP Handler ဆိုသည်မှာ specific URL path သို့ ရောက်ရှိလာသော HTTP request များကို လက်ခံပြီး response ပြန်ပေးရန် တာဝန်ရှိသော function ဖြစ်သည်။</p>
<p>ဤ project ၏ ပထမပိုင်းတွင် data များကို database တွင် မသိမ်းဆည်းဘဲ၊ program run နေစဉ်အတွင်း memory ထဲတွင်သာ သိမ်းဆည်းထားရန် in-memory slice တစ်ခုကို အသုံးပြုပါမည်။</p>
<p><strong><code>main.go</code> File ကို စတင်တည်ဆောက်ခြင်း:</strong></p>
<pre><code class="lang-go">package main

import (
    &quot;encoding/json&quot;
    &quot;fmt&quot;
    &quot;log&quot;
    &quot;net/http&quot;
    &quot;sync&quot;
)

// Task struct
type Task struct {
    ID        int    `json:&quot;id&quot;`
    Title     string `json:&quot;title&quot;`
    Completed bool   `json:&quot;completed&quot;`
}

// Data များကို memory တွင် သိမ်းဆည်းရန်
var (
    tasks  = make(map[int]Task) // Use a map for easier lookup/delete later
    nextID = 1
    mu     sync.Mutex // Mutex for thread-safe access to tasks and nextID
)

// tasksHandler သည် &quot;/tasks&quot; path သို့ ရောက်လာသော requests များကို ကိုင်တွယ်မည်
func tasksHandler(w http.ResponseWriter, r *http.Request) {
    switch r.Method {
    case http.MethodGet:
        getTasks(w, r)
    case http.MethodPost:
        createTask(w, r)
    default:
        // အခြား HTTP methods များကို ခွင့်မပြုပါ
        http.Error(w, &quot;Method not allowed&quot;, http.StatusMethodNotAllowed)
    }
}

// GET /tasks - Task အားလုံးကို ပြန်ပေးသည်
func getTasks(w http.ResponseWriter, r *http.Request) {
    // Map မှ value များကို slice အဖြစ် ပြောင်းလဲခြင်း
    var taskList []Task
    for _, task := range tasks {
        taskList = append(taskList, task)
    }

    w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)
    json.NewEncoder(w).Encode(taskList)
}

// POST /tasks - Task အသစ်တစ်ခု ဖန်တီးသည်
func createTask(w http.ResponseWriter, r *http.Request) {
    var newTask Task

    // Request body မှ JSON ကို decode လုပ်ခြင်း
    if err := json.NewDecoder(r.Body).Decode(&amp;newTask); err != nil {
        http.Error(w, err.Error(), http.StatusBadRequest)
        return
    }

    // ID အသစ်တစ်ခု သတ်မှတ်ပြီး tasks map ထဲသို့ ထည့်သွင်းခြင်း
    newTask.ID = nextID
    tasks[newTask.ID] = newTask
    nextID++

    w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)
    w.WriteHeader(http.StatusCreated) // 201 Created status code
    json.NewEncoder(w).Encode(newTask)
}

func main() {
    // Routing ကို အောက်တွင် ဆက်လက်ရေးသားပါမည်

    // Data များကို thread-safe ဖြစ်စေရန် handler function တစ်ခုချင်းစီတွင်
    // mutex ကို သီးခြားစီ ခေါ်ယူအသုံးပြုပါမည်။
    // ဥပမာ:
    // mu.Lock()
    // defer mu.Unlock()
}</code></pre>
<p><strong>Code ရှင်းလင်းချက်:</strong></p>
<ul>
<li>Data များကို in-memory <code>map</code> တွင် သိမ်းဆည်းထားသည်။ Map ကို အသုံးပြုခြင်းသည် နောင်တွင် task တစ်ခုကို ID ဖြင့် ရှာဖွေ/ဖျက်ပစ်ရန် ပိုမိုလွယ်ကူစေသည်။</li>
<li><code>sync.Mutex</code> ကို အသုံးပြု၍ goroutines များစွာက <code>tasks</code> map နှင့် <code>nextID</code> ကို တစ်ပြိုင်နက်တည်း access လုပ်ခြင်းမှ ကာကွယ်ထားသည် (thread-safety)။</li>
<li><code>tasksHandler</code> သည် request ၏ HTTP method ကို စစ်ဆေးပြီး သက်ဆိုင်ရာ function (<code>getTasks</code> or <code>createTask</code>) ကို ခေါ်ယူပေးသည်။</li>
<li><code>getTasks</code> နှင့် <code>createTask</code> functions များသည် JSON data များကို encode/decode လုပ်ပြီး client သို့ response ပြန်ပေးသည်။</li>
</ul>
<h2 id="routing-">Routing ပြုလုပ်ခြင်း</h2>
<p>Routing ဆိုသည်မှာ URL path တစ်ခုကို သက်ဆိုင်ရာ handler function တစ်ခုနှင့် ချိတ်ဆက်ပေးခြင်းဖြစ်သည်။ <code>net/http</code> package မှ <code>http.HandleFunc</code> ကို အသုံးပြု၍ routing ကို အလွယ်တကူ ပြုလုပ်နိုင်သည်။</p>
<p><strong><code>main</code> function ကို ပြီးပြည့်စုံအောင် ရေးသားခြင်း:</strong></p>
<pre><code class="lang-go">// ... (အပေါ်မှ code များ ဆက်လက်ပါဝင်သည်)

func main() {
    // &quot;/tasks&quot; path ကို tasksHandler နှင့် ချိတ်ဆက်သည်
    http.HandleFunc(&quot;/tasks&quot;, tasksHandler)

    fmt.Println(&quot;Starting REST API server on http://localhost:8080&quot;)
    // Port 8080 တွင် server ကို စတင် run သည်
    if err := http.ListenAndServe(&quot;:8080&quot;, nil); err != nil {
        log.Fatalf(&quot;Could not start server: %s\n&quot;, err.Error())
    }
}</code></pre>
<p>ယခု <code>main.go</code> file ကို <code>go run main.go</code> ဖြင့် run ပြီးနောက် <code>curl</code> သို့မဟုတ် Postman ကဲ့သို့သော tool များကို အသုံးပြု၍ API ကို စမ်းသပ်နိုင်ပြီဖြစ်သည်။</p>
<ul>
<li><strong>Get all tasks:</strong> <code>curl http://localhost:8080/tasks</code></li>
<li><strong>Create a new task:</strong> <code>curl -X POST -H &quot;Content-Type: application/json&quot; -d &#39;{&quot;title&quot;:&quot;Learn Go&quot;, &quot;completed&quot;:false}&#39; http://localhost:8080/tasks</code></li>
</ul>
<h1 id="-project-simple-rest-api-">အခန်း ၁၈: Project - Simple REST API တည်ဆောက်ခြင်း (အပိုင်း ၂)</h1>
<p>ယခင်အခန်းတွင် ကျွန်ုပ်တို့၏ To-Do List API အတွက် အခြေခံ server တစ်ခုကို <code>net/http</code> package ဖြင့် တည်ဆောက်ခဲ့ပြီး <code>GET /tasks</code> နှင့် <code>POST /tasks</code> endpoints များကို implement လုပ်ခဲ့ပါသည်။</p>
<p>ယခုအခန်းတွင် API ကို ပိုမိုစွမ်းဆောင်ရည်ပြည့်ဝအောင် တိုးချဲ့တည်ဆောက်သွားပါမည်။</p>
<ol>
<li>Task တစ်ခုချင်းစီကို ID ဖြင့် <code>GET</code>, <code>PUT</code>, <code>DELETE</code> လုပ်နိုင်သော endpoints များ ထပ်မံထည့်သွင်းပါမည်။</li>
<li>Go 1.22+ တွင် စတင်မိတ်ဆက်ခဲ့သော <strong>Enhanced <code>net/http</code> ServeMux</strong> ကို အသုံးပြု၍ routing ကို ပြန်လည်တည်ဆောက်ပါမည်။</li>
</ol>
<h2 id="go-1-22-standard-library-router">Go 1.22+ Standard Library Router</h2>
<p>Go 1.22 မတိုင်မီက၊ URL path parameters (e.g., <code>/tasks/{id}</code>) များကို ကိုင်တွယ်ရန် <code>gorilla/mux</code> သို့မဟုတ် <code>chi</code> ကဲ့သို့သော third-party library များကို အသုံးပြုလေ့ရှိခဲ့သည်။</p>
<p>သို့သော် Go 1.22 တွင် standard <code>net/http</code> router သည် သိသိသာသာ အဆင့်မြှင့်တင်မှုများ ပါဝင်လာပြီး၊ external dependencies မလိုဘဲ အောက်ပါတို့ကို လုပ်ဆောင်နိုင်ပြီဖြစ်သည်။</p>
<ul>
<li><strong>Method Matching:</strong> HTTP method (<code>GET</code>, <code>POST</code> etc.) ကို pattern တွင် တိုက်ရိုက်သတ်မှတ်နိုင်ခြင်း (e.g., <code>&quot;GET /tasks&quot;</code>).</li>
<li><strong>Path Variables:</strong> URL path အတွင်းရှိ dynamic တန်ဖိုးများကို <code>{name}</code> ပုံစံဖြင့် ဖမ်းယူနိုင်ခြင်း (e.g., <code>/tasks/{id}</code>).</li>
</ul>
<h2 id="api-endpoints-">API Endpoints အသစ်များ ထပ်တိုးခြင်း</h2>
<p>ကျွန်ုပ်တို့၏ API ကို အောက်ပါ endpoints များဖြင့် တိုးချဲ့ပါမည်။</p>
<pre><code class="lang-mermaid">graph TD
    subgraph &quot;To-Do List API (Part 2 - New Endpoints)&quot;
        A[&quot;GET /tasks/{id}&quot;] --&gt; B[&quot;ID ဖြင့် Task တစ်ခုကို ရှာဖွေပြီး&lt;br/&gt;JSON အဖြစ် ပြန်ပေးမည်&quot;]
        C[&quot;PUT /tasks/{id}&quot;] --&gt; D[&quot;ID ဖြင့် Task တစ်ခုကို ရှာဖွေပြီး&lt;br/&gt;Request body မှ JSON data ဖြင့်&lt;br/&gt;Update လုပ်ပြီး ပြန်ပေးမည်&quot;]
        E[&quot;DELETE /tasks/{id}&quot;] --&gt; F[&quot;ID ဖြင့် Task တစ်ခုကို ရှာဖွေပြီး&lt;br/&gt;ဖျက်ပစ်မည်&quot;]
    end</code></pre>
<h2 id="code-refactor-handlers-">Code ကို Refactor လုပ်ခြင်း နှင့် Handlers အသစ်များ ရေးသားခြင်း</h2>
<p>အောက်ပါ code သည် Go 1.22 ၏ router feature အသစ်များကို အသုံးပြု၍ ရေးသားထားသော <code>main.go</code> ၏ ပြီးပြည့်စုံသော version ဖြစ်သည်။</p>
<p><strong><code>main.go</code> (Updated Version)</strong></p>
<pre><code class="lang-go">package main

import (
    &quot;encoding/json&quot;
    &quot;fmt&quot;
    &quot;log&quot;
    &quot;net/http&quot;
    &quot;strconv&quot;
    &quot;sync&quot;
)

type Task struct {
    ID        int    `json:&quot;id&quot;`
    Title     string `json:&quot;title&quot;`
    Completed bool   `json:&quot;completed&quot;`
}

var (
    tasks  = make(map[int]Task)
    nextID = 1
    mu     sync.Mutex
)

// GET /tasks
func getTasks(w http.ResponseWriter, r *http.Request) {
    mu.Lock()
    defer mu.Unlock()
    var taskList []Task
    for _, task := range tasks {
        taskList = append(taskList, task)
    }
    w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)
    json.NewEncoder(w).Encode(taskList)
}

// POST /tasks
func createTask(w http.ResponseWriter, r *http.Request) {
    var newTask Task
    if err := json.NewDecoder(r.Body).Decode(&amp;newTask); err != nil {
        http.Error(w, err.Error(), http.StatusBadRequest)
        return
    }
    mu.Lock()
    defer mu.Unlock()
    newTask.ID = nextID
    tasks[newTask.ID] = newTask
    nextID++
    w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)
    w.WriteHeader(http.StatusCreated)
    json.NewEncoder(w).Encode(newTask)
}

// --- Handler အသစ်များ ---

// GET /tasks/{id}
func getTask(w http.ResponseWriter, r *http.Request) {
    // Go 1.22: r.PathValue(&quot;id&quot;) ကို အသုံးပြု၍ path variable ကို ရယူသည်
    idStr := r.PathValue(&quot;id&quot;)
    id, err := strconv.Atoi(idStr)
    if err != nil {
        http.Error(w, &quot;Invalid task ID&quot;, http.StatusBadRequest)
        return
    }

    mu.Lock()
    defer mu.Unlock()

    task, ok := tasks[id]
    if !ok {
        http.Error(w, &quot;Task not found&quot;, http.StatusNotFound)
        return
    }

    w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)
    json.NewEncoder(w).Encode(task)
}

// PUT /tasks/{id}
func updateTask(w http.ResponseWriter, r *http.Request) {
    idStr := r.PathValue(&quot;id&quot;)
    id, err := strconv.Atoi(idStr)
    if err != nil {
        http.Error(w, &quot;Invalid task ID&quot;, http.StatusBadRequest)
        return
    }

    var updatedTask Task
    if err := json.NewDecoder(r.Body).Decode(&amp;updatedTask); err != nil {
        http.Error(w, err.Error(), http.StatusBadRequest)
        return
    }

    mu.Lock()
    defer mu.Unlock()

    if _, ok := tasks[id]; !ok {
        http.Error(w, &quot;Task not found&quot;, http.StatusNotFound)
        return
    }

    updatedTask.ID = id
    tasks[id] = updatedTask

    w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)
    json.NewEncoder(w).Encode(updatedTask)
}

// DELETE /tasks/{id}
func deleteTask(w http.ResponseWriter, r *http.Request) {
    idStr := r.PathValue(&quot;id&quot;)
    id, err := strconv.Atoi(idStr)
    if err != nil {
        http.Error(w, &quot;Invalid task ID&quot;, http.StatusBadRequest)
        return
    }

    mu.Lock()
    defer mu.Unlock()

    if _, ok := tasks[id]; !ok {
        http.Error(w, &quot;Task not found&quot;, http.StatusNotFound)
        return
    }

    delete(tasks, id)
    w.WriteHeader(http.StatusNoContent) // 204 No Content
}

func main() {
    // Go 1.22: NewServeMux ကို အသုံးပြုခြင်း
    mux := http.NewServeMux()

    // Pattern တွင် Method နှင့် Path Variable `{id}` ကို ထည့်သွင်းသတ်မှတ်ခြင်း
    mux.HandleFunc(&quot;GET /tasks&quot;, getTasks)
    mux.HandleFunc(&quot;POST /tasks&quot;, createTask)
    mux.HandleFunc(&quot;GET /tasks/{id}&quot;, getTask)
    mux.HandleFunc(&quot;PUT /tasks/{id}&quot;, updateTask)
    mux.HandleFunc(&quot;DELETE /tasks/{id}&quot;, deleteTask)

    fmt.Println(&quot;Starting REST API server on http://localhost:8080&quot;)
    // http.ListenAndServe တွင် mux ကို pass လုပ်သည်
    if err := http.ListenAndServe(&quot;:8080&quot;, mux); err != nil {
        log.Fatalf(&quot;Could not start server: %s\n&quot;, err.Error())
    }
}</code></pre>
<p><strong>Code ရှင်းလင်းချက် (Go 1.22 Features):</strong></p>
<ol>
<li><strong><code>http.NewServeMux()</code>:</strong> Standard library ၏ multiplexer အသစ်ကို အသုံးပြုသည်။</li>
<li><strong>Strict Routing Patterns:</strong> <code>mux.HandleFunc</code> တွင် <code>&quot;GET /tasks&quot;</code> သို့မဟုတ် <code>&quot;DELETE /tasks/{id}&quot;</code> ကဲ့သို့ Method နှင့် Path ကို တိုက်ရိုက်တွဲလျက် သတ်မှတ်နိုင်သည်။ HTTP Method မှားယွင်းပါက <code>405 Method Not Allowed</code> ကို အလိုအလျောက် ပြန်ပေးသည်။</li>
<li><strong><code>r.PathValue(&quot;id&quot;)</code>:</strong> Request object မှ <code>PathValue</code> methood ကို ခေါ်ယူ၍ URL path variable (<code>{id}</code>) ၏ တန်ဖိုးကို အလွယ်တကူ ရယူနိုင်သည်။</li>
</ol>
<p>ယခုအခါ Third-party library များကို အားကိုးစရာမလိုဘဲ Standard Library သက်သက်ဖြင့် Modern REST API တစ်ခုကို တည်ဆောက်နိုင်ပြီဖြစ်သည်။</p>
<h1 id="-project-simple-rest-api-database-integration">အခန်း ၁၉: Project - Simple REST API တည်ဆောက်ခြင်း (အပိုင်း ၃) - Database Integration</h1>
<p>ယခင် အခန်း ၁၇ နှင့် ၁၈ တွင်၊ ကျွန်ုပ်တို့သည် in-memory data store ကို အသုံးပြု၍ REST API တစ်ခုကို တည်ဆောက်ခဲ့သည်။ ၎င်းသည် API ၏ အလုပ်လုပ်ပုံကို လေ့လာရန် ကောင်းမွန်သော်လည်း၊ application ကို restart လုပ်လိုက်တိုင်း data များ ပျောက်ဆုံးသွားမည်ဖြစ်သည်။ ဤအခန်းတွင်၊ ကျွန်ုပ်တို့၏ data များကို PostgreSQL database တွင် သိမ်းဆည်းခြင်းဖြင့် data persistence ကို အကောင်အထည်ဖော်ပါမည်။</p>
<h2 id="-database-sql-package-"><code>database/sql</code> Package ကို အသုံးပြုခြင်း</h2>
<p>Go ၏ standard library တွင်ပါဝင်သော <code>database/sql</code> package သည် SQL (သို့မဟုတ် SQL-like) databases များနှင့် အလုပ်လုပ်ရန်အတွက် generic interface တစ်ခုကို ပံ့ပိုးပေးသည်။ ၎င်းသည် database-specific details များကို abstract လုပ်ပေးထားပြီး၊ ကျွန်ုပ်တို့အား တသမတ်တည်းဖြစ်သော API ဖြင့် database operations များ လုပ်ဆောင်နိုင်ရန် ကူညီပေးသည်။</p>
<p><code>database/sql</code> package ကိုယ်တိုင်က database နှင့် တိုက်ရိုက်စကားပြောနိုင်စွမ်းမရှိပါ။ ၎င်းသည် <strong>database driver</strong> များနှင့်အတူ အလုပ်လုပ်သည်။ ကျွန်ုပ်တို့သည် PostgreSQL နှင့် ချိတ်ဆက်လိုပါက၊ PostgreSQL အတွက် driver တစ်ခုကို import လုပ်ပေးရန် လိုအပ်သည်။</p>
<h2 id="database-driver-">Database Driver ထည့်သွင်းခြင်း နှင့် ချိတ်ဆက်ခြင်း</h2>
<p>ဤ project အတွက်၊ ကျွန်ုပ်တို့သည် PostgreSQL ကို အသုံးပြုပြီး <code>pq</code> driver ကို ထည့်သွင်းပါမည်။</p>
<p><strong>1. Driver ကို Install လုပ်ခြင်း:</strong></p>
<p>Terminal တွင် အောက်ပါ command ကို run ပါ။</p>
<pre><code class="lang-sh">go get github.com/lib/pq</code></pre>
<p>ဤ command သည် <code>pq</code> driver ကို download လုပ်ပြီး ကျွန်ုပ်တို့၏ <code>go.mod</code> file ထဲသို့ dependency အဖြစ် ထည့်သွင်းပေးပါလိမ့်မည်။</p>
<p><strong>2. Database နှင့် ချိတ်ဆက်ခြင်း:</strong></p>
<p><code>main.go</code> သို့မဟုတ် database connection ကို စီမံခန့်ခွဲမည့် file တွင် အောက်ပါကဲ့သို့ ရေးသားရမည်။</p>
<pre><code class="lang-go">package main

import (
    &quot;database/sql&quot;
    &quot;fmt&quot;
    &quot;log&quot;

    _ &quot;github.com/lib/pq&quot; // The database driver
)

const (
    dbHost = &quot;localhost&quot;
    dbPort = 5432
    dbUser = &quot;your_username&quot; // သင်၏ PostgreSQL username ကို ပြောင်းပါ
    dbPassword = &quot;your_password&quot; // သင်၏ PostgreSQL password ကို ပြောင်းပါ
    dbName = &quot;your_dbname&quot;   // သင်၏ database name ကို ပြောင်းပါ
)

&gt; [!TIP]
&gt; **Security Best Practice**: Production တွင် password များကို code ထဲတွင် hardcode မရေးသင့်ပါ။ `os.Getenv(&quot;DB_PASSWORD&quot;)` ကဲ့သို့သော environment variable များမှတဆင့် ဖတ်ယူအသုံးပြုခြင်းသည် ပိုမိုလုံခြုံစိတ်ချရသည်။

func main() {
    // Connection string ကို တည်ဆောက်ခြင်း
    psqlInfo := fmt.Sprintf(&quot;host=%s port=%d user=%s password=%s dbname=%s sslmode=disable&quot;,
        dbHost, dbPort, dbUser, dbPassword, dbName)

    // Database connection ကို ဖွင့်ခြင်း
    db, err := sql.Open(&quot;postgres&quot;, psqlInfo)
    if err != nil {
        log.Fatalf(&quot;Error opening database: %q&quot;, err)
    }
    defer db.Close()

    // Connection အောင်မြင်မှုရှိမရှိ စစ်ဆေးခြင်း
    err = db.Ping()
    if err != nil {
        log.Fatalf(&quot;Error connecting to the database: %q&quot;, err)
    }

    fmt.Println(&quot;Successfully connected to the database!&quot;)

    // ... (API server ကို ဤနေရာတွင် run ပါမည်)
}</code></pre>
<p><strong>အရေးကြီးသော မှတ်ချက်များ:</strong></p>
<ul>
<li><code>import _ &quot;github.com/lib/pq&quot;</code>: <code>_</code> (blank identifier) ကို အသုံးပြုရခြင်းမှာ၊ ကျွန်ုပ်တို့သည် <code>pq</code> package ကို တိုက်ရိုက်ခေါ်သုံးနေခြင်းမဟုတ်ဘဲ၊ ၎င်း၏ <code>init</code> function ကို run စေခြင်းဖြင့် <code>database/sql</code> package တွင် &quot;postgres&quot; driver အဖြစ် register လုပ်စေလိုသောကြောင့် ဖြစ်သည်။</li>
<li><code>sql.Open</code> သည် database connection ကို ချက်ချင်းမဖွင့်ပါ။ ၎င်းသည် နောက်ကွယ်တွင် connection pool တစ်ခုကို setup လုပ်ပေးပြီး လိုအပ်မှသာ connection များကို တည်ဆောက်သည်။</li>
<li><code>db.Ping()</code> ဖြင့် connection အမှန်တကယ်ရမရ စစ်ဆေးရန် အလွန်အရေးကြီးသည်။</li>
</ul>
<h2 id="crud-operations-">CRUD Operations များ ရေးသားခြင်း</h2>
<p>HTTP handlers များထဲတွင် database logic များကို တိုက်ရိုက်ရေးသားခြင်းထက်၊ သီးသန့် file သို့မဟုတ် package (<code>store</code> သို့မဟုတ် <code>models</code> ကဲ့သို့) တစ်ခုတွင် ခွဲထုတ်ရေးသားခြင်းသည် code ကို ပိုမိုရှင်းလင်းစေသည်။</p>
<p><strong>ဥပမာ: <code>products</code> table အတွက် CRUD functions များ</strong></p>
<p><code>products</code> table ၏ schema မှာ အောက်ပါအတိုင်းဟု ယူဆပါမည်။</p>
<pre><code class="lang-sql">CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    price NUMERIC(10, 2) NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);</code></pre>
<p><strong><code>store.go</code></strong></p>
<pre><code class="lang-go">package main

import &quot;database/sql&quot;

// Product struct သည် products table row တစ်ခုကို ကိုယ်စားပြုသည်
type Product struct {
    ID    int     `json:&quot;id&quot;`
    Name  string  `json:&quot;name&quot;`
    Price float64 `json:&quot;price&quot;`
}

// CreateProduct သည် product အသစ်တစ်ခုကို database ထဲသို့ ထည့်ပေးသည်
func CreateProduct(db *sql.DB, product *Product) (int, error) {
    var productID int
    // $1, $2 တို့သည် SQL injection ကို ကာကွယ်ပေးသော placeholders များဖြစ်သည်
    err := db.QueryRow(
        &quot;INSERT INTO products (name, price) VALUES ($1, $2) RETURNING id&quot;,
        product.Name, product.Price,
    ).Scan(&amp;productID)

    if err != nil {
        return 0, err
    }
    return productID, nil
}

// GetProduct သည် ID ဖြင့် product တစ်ခုကို ရှာဖွေပေးသည်
func GetProduct(db *sql.DB, id int) (*Product, error) {
    var p Product
    err := db.QueryRow(&quot;SELECT id, name, price FROM products WHERE id = $1&quot;, id).Scan(&amp;p.ID, &amp;p.Name, &amp;p.Price)
    if err != nil {
        if err == sql.ErrNoRows {
            return nil, nil // Product မတွေ့ပါ
        }
        return nil, err
    }
    return &amp;p, nil
}

// GetProducts သည် products အားလုံးကို ပြန်ပေးသည်
func GetProducts(db *sql.DB) ([]Product, error) {
    rows, err := db.Query(&quot;SELECT id, name, price FROM products&quot;)
    if err != nil {
        return nil, err
    }
    defer rows.Close()

    var products []Product
    for rows.Next() {
        var p Product
        if err := rows.Scan(&amp;p.ID, &amp;p.Name, &amp;p.Price); err != nil {
            return nil, err
        }
        products = append(products, p)
    }
    return products, nil
}

// UpdateProduct သည် product အချက်အလက်များကို ပြင်ဆင်သည်
func UpdateProduct(db *sql.DB, id int, product *Product) (int64, error) {
    res, err := db.Exec(&quot;UPDATE products SET name = $1, price = $2 WHERE id = $3&quot;, product.Name, product.Price, id)
    if err != nil {
        return 0, err
    }
    return res.RowsAffected()
}

// DeleteProduct သည် product တစ်ခုကို ဖျက်ပစ်သည်
func DeleteProduct(db *sql.DB, id int) (int64, error) {
    res, err := db.Exec(&quot;DELETE FROM products WHERE id = $1&quot;, id)
    if err != nil {
        return 0, err
    }
    return res.RowsAffected()
}</code></pre>
<h2 id="api-endpoints-database-">API Endpoints များကို Database နှင့် ချိတ်ဆက်ခြင်း</h2>
<p>ယခု ကျွန်ုပ်တို့၏ HTTP handlers များကို ယခင် in-memory store အစား database functions များကို ခေါ်သုံးရန် ပြင်ဆင်ပါမည်။ Handler များသည် <code>*sql.DB</code> instance ကို access လုပ်ရန် လိုအပ်မည်ဖြစ်သည်။</p>
<pre><code class="lang-go">// main.go တွင် *sql.DB ကို handler များထံ pass လုပ်ရန် struct တစ်ခု သတ်မှတ်နိုင်သည်
type Env struct {
    db *sql.DB
}

func main() {
    // ... (db connection တည်ဆောက်ပြီး)

    env := &amp;Env{db: db}

    http.HandleFunc(&quot;/products&quot;, env.getProductsHandler)
    http.HandleFunc(&quot;/products/create&quot;, env.createProductHandler)

    // ... server start
}

func (e *Env) getProductsHandler(w http.ResponseWriter, r *http.Request) {
    if r.Method != http.MethodGet {
        http.Error(w, &quot;Method not allowed&quot;, http.StatusMethodNotAllowed)
        return
    }

    products, err := GetProducts(e.db)
    if err != nil {
        http.Error(w, &quot;Failed to fetch products&quot;, http.StatusInternalServerError)
        return
    }

    json.NewEncoder(w).Encode(products)
}

func (e *Env) createProductHandler(w http.ResponseWriter, r *http.Request) {
    if r.Method != http.MethodPost {
        http.Error(w, &quot;Method not allowed&quot;, http.StatusMethodNotAllowed)
        return
    }

    var p Product
    if err := json.NewDecoder(r.Body).Decode(&amp;p); err != nil {
        http.Error(w, &quot;Invalid request body&quot;, http.StatusBadRequest)
        return
    }

    productID, err := CreateProduct(e.db, &amp;p)
    if err != nil {
        http.Error(w, &quot;Failed to create product&quot;, http.StatusInternalServerError)
        return
    }

    p.ID = productID
    w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)
    w.WriteHeader(http.StatusCreated)
    json.NewEncoder(w).Encode(p)
}

func (e *Env) updateProductHandler(w http.ResponseWriter, r *http.Request) {
    if r.Method != http.MethodPut {
        http.Error(w, &quot;Method not allowed&quot;, http.StatusMethodNotAllowed)
        return
    }

    idStr := r.URL.Path[len(&quot;/products/&quot;):]
    id, err := strconv.Atoi(idStr)
    if err != nil {
        http.Error(w, &quot;Invalid product ID&quot;, http.StatusBadRequest)
        return
    }

    var p Product
    if err := json.NewDecoder(r.Body).Decode(&amp;p); err != nil {
        http.Error(w, &quot;Invalid request body&quot;, http.StatusBadRequest)
        return
    }

    rowsAffected, err := UpdateProduct(e.db, id, &amp;p)
    if err != nil {
        http.Error(w, &quot;Failed to update product&quot;, http.StatusInternalServerError)
        return
    }

    if rowsAffected == 0 {
        http.Error(w, &quot;Product not found&quot;, http.StatusNotFound)
        return
    }

    // Updated product with ID
    p.ID = id
    json.NewEncoder(w).Encode(p)
}

func (e *Env) deleteProductHandler(w http.ResponseWriter, r *http.Request) {
    if r.Method != http.MethodDelete {
        http.Error(w, &quot;Method not allowed&quot;, http.StatusMethodNotAllowed)
        return
    }

    idStr := r.URL.Path[len(&quot;/products/&quot;):]
    id, err := strconv.Atoi(idStr)
    if err != nil {
        http.Error(w, &quot;Invalid product ID&quot;, http.StatusBadRequest)
        return
    }

    rowsAffected, err := DeleteProduct(e.db, id)
    if err != nil {
        http.Error(w, &quot;Failed to delete product&quot;, http.StatusInternalServerError)
        return
    }

    if rowsAffected == 0 {
        http.Error(w, &quot;Product not found&quot;, http.StatusNotFound)
        return
    }

    w.WriteHeader(http.StatusNoContent)
}

func (e *Env) getProductHandler(w http.ResponseWriter, r *http.Request) {
    if r.Method != http.MethodGet {
        http.Error(w, &quot;Method not allowed&quot;, http.StatusMethodNotAllowed)
        return
    }

    idStr := r.URL.Path[len(&quot;/products/&quot;):]
    id, err := strconv.Atoi(idStr)
    if err != nil {
        http.Error(w, &quot;Invalid product ID&quot;, http.StatusBadRequest)
        return
    }

    product, err := GetProduct(e.db, id)
    if err != nil {
        http.Error(w, &quot;Failed to get product&quot;, http.StatusInternalServerError)
        return
    }

    if product == nil {
        http.Error(w, &quot;Product not found&quot;, http.StatusNotFound)
        return
    }

    json.NewEncoder(w).Encode(product)
}


// ... အခြား handlers များကိုလည်း အလားတူ ပြင်ဆင်ပါ</code></pre>
<p>ဤအခန်းပြီးဆုံးသောအခါ၊ သင်၏ REST API သည် data များကို database တွင် အမှန်တကယ် သိမ်းဆည်းနိုင်၊ ပြန်လည်ထုတ်ယူနိုင်၊ ပြင်ဆင်နိုင်၊ နှင့် ဖျက်ပစ်နိုင်ပြီ ဖြစ်သည်။ ၎င်းသည် production-ready application တစ်ခု တည်ဆောက်ရန်အတွက် အရေးကြီးသော ခြေလှမ်းတစ်ခုဖြစ်သည်။</p>
<h1 id="-data-structures-algorithms-">အခန်း ၂၀: အသုံးများသော Data Structures နှင့် Algorithms များ</h1>
<p>Software engineering တွင် ထိရောက်ပြီး စွမ်းဆောင်ရည်မြင့်မားသော program များ ရေးသားနိုင်ရန်အတွက် Data Structures (အချက်အလက် တည်ဆောက်ပုံ) နှင့် Algorithms (တွက်ချက်နည်းစနစ်) များကို နားလည်တတ်ကျွမ်းခြင်းသည် အလွန်အရေးကြီးပါသည်။ ဤအခန်းတွင် Go language ကို အသုံးပြု၍ အသုံးအများဆုံး DSA concept များကို လက်တွေ့ code များနှင့်တကွ အသေးစိတ် လေ့လာသွားပါမည်။</p>
<h2 id="linked-lists">Linked Lists</h2>
<p><strong>Linked List</strong> ဆိုသည်မှာ data element များ (Nodes) ကို sequence အလိုက် ချိတ်ဆက်ထားသော linear data structure တစ်ခုဖြစ်သည်။ Array/Slice နှင့်မတူဘဲ၊ linked list ၏ elements များသည် memory တွင် တစ်ဆက်တည်းရှိမနေဘဲ၊ node တစ်ခုစီက နောက် node တစ်ခု၏ memory address ကို pointer ဖြင့် ညွှန်ပြထားသည်။</p>
<ul>
<li><strong>Node:</strong> Data နှင့် နောက် node ကို ညွှန်ပြသော pointer (<code>next</code>) တို့ ပါဝင်သည်။</li>
<li><strong>Head:</strong> List ၏ ပထမဆုံး node ကို ညွှန်ပြသော pointer ဖြစ်သည်။</li>
</ul>
<pre><code class="lang-mermaid">graph LR
    A[Head] --&gt; B(Node 1&lt;br/&gt;Data: 10&lt;br/&gt;Next: ptr)
    B --&gt; C(Node 2&lt;br/&gt;Data: 20&lt;br/&gt;Next: ptr)
    C --&gt; D(Node 3&lt;br/&gt;Data: 30&lt;br/&gt;Next: ptr)
    D --&gt; E((nil))</code></pre>
<p><strong>Go ဖြင့် ရေးသားခြင်း:</strong></p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

// Node struct
type Node struct {
    Data int
    Next *Node
}

// LinkedList struct
type LinkedList struct {
    Head *Node
}

// Append method သည် list ၏ အဆုံးတွင် node အသစ်တစ်ခု ထည့်ပေးသည်
func (ll *LinkedList) Append(data int) {
    newNode := &amp;Node{Data: data}
    if ll.Head == nil {
        ll.Head = newNode
        return
    }

    current := ll.Head
    for current.Next != nil {
        current = current.Next
    }
    current.Next = newNode
}

// DeleteWithValue method သည် ပထမဆုံးတွေ့ရသော value ကို list မှ ဖျက်ပစ်သည်
func (ll *LinkedList) DeleteWithValue(value int) {
    if ll.Head == nil {
        return
    }
    // Head node ကိုယ်တိုင်က ဖျက်ရမည့် value ဖြစ်ပါက
    if ll.Head.Data == value {
        ll.Head = ll.Head.Next
        return
    }
    // List ထဲတွင် ရှာဖွေပြီး ဖျက်ခြင်း
    current := ll.Head
    for current.Next != nil {
        if current.Next.Data == value {
            current.Next = current.Next.Next // Bypass the node
            return
        }
        current = current.Next
    }
}

func main() {
    list := LinkedList{}
    list.Append(10)
    list.Append(20)
    list.Append(30)

    // Print the list
    current := list.Head
    for current != nil {
        fmt.Printf(&quot;%d -&gt; &quot;, current.Data)
        current = current.Next
    }
    fmt.Println(&quot;nil&quot;)
}</code></pre>
<h2 id="stacks-and-queues">Stacks and Queues</h2>
<h3 id="stack-lifo-last-in-first-out-">Stack (LIFO - Last-In, First-Out)</h3>
<p>Stack ဆိုသည်မှာ နောက်ဆုံးထည့်လိုက်သော element ကို ပထမဆုံး ပြန်ထုတ်ရသည့် data structure ဖြစ်သည်။ ဥပမာ- ပန်းကန်ပြားများ ထပ်ထားခြင်းနှင့်တူသည်။ Go တွင် slice ကို အသုံးပြု၍ stack ကို အလွယ်တကူ implement လုပ်နိုင်သည်။</p>
<ul>
<li><strong>Push:</strong> Stack ၏ အပေါ်ဆုံးတွင် element အသစ်တစ်ခု ထပ်ထည့်ခြင်း (<code>append</code>)။</li>
<li><strong>Pop:</strong> Stack ၏ အပေါ်ဆုံးမှ element ကို ဖယ်ထုတ်ခြင်း။</li>
</ul>
<pre><code class="lang-go">type Stack []string

func (s *Stack) Push(val string) {
    *s = append(*s, val)
}

func (s *Stack) Pop() (string, bool) {
    if len(*s) == 0 {
        return &quot;&quot;, false // Stack is empty
    }
    index := len(*s) - 1
    element := (*s)[index]
    *s = (*s)[:index]
    return element, true
}</code></pre>
<h3 id="queue-fifo-first-in-first-out-">Queue (FIFO - First-In, First-Out)</h3>
<p>Queue ဆိုသည်မှာ ပထမဆုံးထည့်လိုက်သော element ကို ပထမဆုံး ပြန်ထုတ်ရသည့် data structure ဖြစ်သည်။ ဥပမာ- တန်းစီခြင်းနှင့်တူသည်။</p>
<ul>
<li><strong>Enqueue:</strong> Queue ၏ အနောက်ဆုံးတွင် element အသစ်တစ်ခု ထည့်ခြင်း (<code>append</code>)။</li>
<li><strong>Dequeue:</strong> Queue ၏ အရှေ့ဆုံးမှ element ကို ဖယ်ထုတ်ခြင်း။</li>
</ul>
<pre><code class="lang-go">type Queue []string

func (q *Queue) Enqueue(val string) {
    *q = append(*q, val)
}

func (q *Queue) Dequeue() (string, bool) {
    if len(*q) == 0 {
        return &quot;&quot;, false // Queue is empty
    }
    element := (*q)[0]
    *q = (*q)[1:]
    return element, true
}</code></pre>
<h2 id="trees-binary-search-tree-">Trees (Binary Search Tree)</h2>
<p><strong>Binary Search Tree (BST)</strong> ဆိုသည်မှာ tree data structure တစ်မျိုးဖြစ်ပြီး node တိုင်းတွင် အောက်ပါ ဂုဏ်သတ္တိများရှိသည်။</p>
<ol>
<li>ဘယ်ဘက် child node ၏ တန်ဖိုးသည် parent node ၏ တန်ဖိုးထက် အမြဲငယ်ရမည်။</li>
<li>ညာဘက် child node ၏ တန်ဖိုးသည် parent node ၏ တန်ဖိုးထက် အမြဲကြီးရမည်။</li>
<li>ဘယ်ဘက်နှင့် ညာဘက် subtrees များသည်လည်း binary search trees များ ဖြစ်ရမည်။</li>
</ol>
<p>ဤဂုဏ်သတ္တိကြောင့် data များကို ရှာဖွေရာတွင် အလွန်မြန်ဆန်သည် (ပျမ်းမျှ O(log n))။</p>
<pre><code class="lang-mermaid">graph TD
    A(10) --&gt; B(5)
    A --&gt; C(15)
    B --&gt; D(2)
    B --&gt; E(7)
    C --&gt; F(12)
    C --&gt; G(18)</code></pre>
<p><strong>Go ဖြင့် ရေးသားခြင်း:</strong></p>
<pre><code class="lang-go">type TreeNode struct {
    Value int
    Left  *TreeNode
    Right *TreeNode
}

func (n *TreeNode) Insert(value int) {
    if value &lt; n.Value {
        if n.Left == nil {
            n.Left = &amp;TreeNode{Value: value}
        } else {
            n.Left.Insert(value)
        }
    } else if value &gt; n.Value {
        if n.Right == nil {
            n.Right = &amp;TreeNode{Value: value}
        } else {
            n.Right.Insert(value)
        }
    }
}

// Search method သည် tree ထဲတွင် value ရှိ/မရှိ ရှာဖွေပေးသည်
func (n *TreeNode) Search(value int) bool {
    if n == nil {
        return false
    }
    if value &lt; n.Value {
        return n.Left.Search(value)
    } else if value &gt; n.Value {
        return n.Right.Search(value)
    }
    return true // value == n.Value
}</code></pre>
<h2 id="sorting-algorithms">Sorting Algorithms</h2>
<h3 id="bubble-sort">Bubble Sort</h3>
<p>Bubble Sort သည် ရိုးရှင်းသော sorting algorithm တစ်ခုဖြစ်ပြီး၊ ကပ်လျက် element နှစ်ခုကို နှိုင်းယှဉ်ကာ နေရာမှန်မရောက်မချင်း အပြန်အလှန် လဲလှယ်ပေးသည်။ ၎င်းသည် performance မကောင်းသော်လည်း (O(n²))၊ sorting ၏ အခြေခံကို နားလည်ရန်အတွက် ကောင်းမွန်သော ဥပမာတစ်ခုဖြစ်သည်။</p>
<pre><code class="lang-go">func BubbleSort(arr []int) {
    n := len(arr)
    for i := 0; i &lt; n-1; i++ {
        for j := 0; j &lt; n-i-1; j++ {
            if arr[j] &gt; arr[j+1] {
                arr[j], arr[j+1] = arr[j+1], arr[j] // Swap
            }
        }
    }
}</code></pre>
<h3 id="quick-sort">Quick Sort</h3>
<p>Quick Sort သည် &quot;divide and conquer&quot; နည်းစနစ်ကို အသုံးပြုထားသော ပိုမိုထိရောက်သည့် sorting algorithm ဖြစ်သည်။</p>
<ol>
<li>Array ထဲမှ element တစ်ခုကို <strong>pivot</strong> အဖြစ် ရွေးချယ်သည်။</li>
<li>Array ကို pivot ထက်ငယ်သော elements များ (ဘယ်ဘက်) နှင့် pivot ထက်ကြီးသော elements များ (ညာဘက်) ဟူ၍ နှစ်ပိုင်းခွဲ (partition) သည်။</li>
<li>ဘယ်ဘက်နှင့် ညာဘက် sub-arrays များကို Quick Sort ဖြင့် recursive ပြန်ခေါ်၍ sort လုပ်သည်။</li>
</ol>
<p>ပျမ်းမျှအားဖြင့် ၎င်း၏ time complexity မှာ O(n log n) ဖြစ်သောကြောင့် အလွန်မြန်ဆန်သည်။</p>
<pre><code class="lang-go">func QuickSort(arr []int) []int {
    if len(arr) &lt; 2 {
        return arr
    }

    left, right := 0, len(arr)-1
    pivotIndex := len(arr) / 2
    arr[pivotIndex], arr[right] = arr[right], arr[pivotIndex]

    for i := range arr {
        if arr[i] &lt; arr[right] {
            arr[i], arr[left] = arr[left], arr[i]
            left++
        }
    }

    arr[left], arr[right] = arr[right], arr[left]

    QuickSort(arr[:left])
    QuickSort(arr[left+1:])

    return arr
}</code></pre>
<h2 id="backtracking-">Backtracking (နောက်ပြန်ဆုတ်၍ ရှာဖွေခြင်း)</h2>
<p><strong>Backtracking</strong> ဆိုသည်မှာ ပြဿနာတစ်ခု၏ solution ကို ရှာဖွေရာတွင် ဖြစ်နိုင်ခြေရှိသော လမ်းကြောင်း (choices) အားလုံးကို တစ်ဆင့်ချင်း စမ်းသပ်တည်ဆောက်သွားသည့် algorithm နည်းစနစ်ဖြစ်သည်။ ဝင်္ကပါတစ်ခုကို ဖြေရှင်းသကဲ့သို့ပင်၊ လမ်းကြောင်းတစ်ခုသည် solution သို့ မရောက်နိုင်တော့ဟု သိရှိပါက (dead end)၊ နောက်ဆုံး ပြုလုပ်ခဲ့သော choice ကို ပြန်ဖျက်ပြီး နောက်ပြန်ဆုတ် (backtrack) ကာ အခြားလမ်းကြောင်းတစ်ခုကို ရွေးချယ်စမ်းသပ်သည်။</p>
<pre><code class="lang-mermaid">graph TD
    Start --&gt; Choice1
    Choice1 --&gt; Choice2
    Choice2 --&gt; DeadEnd1[x Dead End]
    Choice2 -- &quot;Backtrack&quot; --&gt; Choice1
    Choice1 --&gt; Choice3
    Choice3 --&gt; Solution[Solution Found!]</code></pre>
<p>Backtracking ကို Sudoku solvers, N-Queens problem, နှင့် permutations/combinations ရှာဖွေခြင်းကဲ့သို့သော ပြဿနာများတွင် တွင်ကျယ်စွာ အသုံးပြုသည်။</p>
<h3 id="-string-permutations">ဥပမာ ၁: String Permutations</h3>
<p>String တစ်ခု (<code>&quot;ABC&quot;</code>) ၏ ဖြစ်နိုင်ခြေရှိသော ပြောင်းပြန်လှန်လှယ်မှု (permutations) အားလုံးကို ရှာဖွေခြင်း။</p>
<pre><code class="lang-go">func findPermutations(s string) []string {
    var result []string
    var permute func(prefix string, str string)

    permute = func(prefix string, str string) {
        n := len(str)
        if n == 0 {
            result = append(result, prefix)
        } else {
            for i := 0; i &lt; n; i++ {
                // Recursive call: i-th character ကို prefix ထဲထည့်ပြီး ကျန် string ကို pass လုပ်သည်
                permute(prefix+string(str[i]), str[0:i]+str[i+1:n])
            }
        }
    }

    permute(&quot;&quot;, s)
    return result
}</code></pre>
<h3 id="-n-queens-problem">ဥပမာ ၂: N-Queens Problem</h3>
<p><strong>ပြဿနာ:</strong> N x N စစ်တုရင်ခုံပေါ်တွင် ဘုရင်မ (Queen) N ကောင်ကို တစ်ကောင်နှင့်တစ်ကောင် တိုက်ခိုက်၍မရအောင် (တူညီသော row, column, သို့မဟုတ် diagonal တွင် မရှိစေရ) မည်သို့နေရာချမည်နည်း။</p>
<p><strong>Backtracking ဖြင့် ဖြေရှင်းခြင်း:</strong></p>
<ol>
<li>ပထမဆုံး row မှ စတင်ပြီး column တစ်ခုတွင် Queen တစ်ကောင်ကို ချကြည့်ပါ။</li>
<li>ထိုနေရာသည် အခြား Queen များနှင့် conflict ဖြစ်/မဖြစ် စစ်ဆေးပါ။</li>
<li>Conflict မရှိပါက နောက်တစ် row သို့ ဆက်သွားပြီး အဆင့် ၁ ကို ပြန်လုပ်ပါ။</li>
<li>Conflict ရှိပါက (သို့မဟုတ် နောက် row တွင် နေရာချရန်မဖြစ်နိုင်ပါက) လက်ရှိ Queen ကို ဖယ်ရှားပြီး (backtrack)၊ လက်ရှိ row ၏ နောက် column တစ်ခုတွင် ပြန်ချကြည့်ပါ။</li>
<li>Queen N ကောင်လုံး အောင်မြင်စွာ နေရာချပြီးပါက solution တစ်ခုကို တွေ့ရှိပြီဖြစ်သည်။</li>
</ol>
<pre><code class="lang-go">func solveNQueens(n int) [][]string {
    var result [][]string
    board := make([][]byte, n)
    for i := range board {
        board[i] = make([]byte, n)
        for j := range board[i] {
            board[i][j] = &#39;.&#39;
        }
    }

    var backtrack func(row int)
    backtrack = func(row int) {
        if row == n {
            var solution []string
            for _, r := range board {
                solution = append(solution, string(r))
            }
            result = append(result, solution)
            return
        }

        for col := 0; col &lt; n; col++ {
            if isValid(board, row, col, n) {
                board[row][col] = &#39;Q&#39;
                backtrack(row + 1)
                board[row][col] = &#39;.&#39; // Backtrack
            }
        }
    }

    backtrack(0)
    return result
}

func isValid(board [][]byte, row, col, n int) bool {
    // Check column
    for i := 0; i &lt; row; i++ {
        if board[i][col] == &#39;Q&#39; {
            return false
        }
    }
    // Check upper-left diagonal
    for i, j := row-1, col-1; i &gt;= 0 &amp;&amp; j &gt;= 0; i, j = i-1, j-1 {
        if board[i][j] == &#39;Q&#39; {
            return false
        }
    }
    // Check upper-right diagonal
    for i, j := row-1, col+1; i &gt;= 0 &amp;&amp; j &lt; n; i, j = i-1, j+1 {
        if board[i][j] == &#39;Q&#39; {
            return false
        }
    }
    return true
}</code></pre>
<h2 id="dynamic-programming-dp-">Dynamic Programming (DP)</h2>
<p><strong>Dynamic Programming</strong> ဆိုသည်မှာ ပြဿနာကြီးတစ်ခုကို ပိုမိုသေးငယ်ပြီး <strong>ထပ်နေသော ပြဿနာငယ်များ (overlapping subproblems)</strong> အဖြစ် ခွဲခြမ်းစိတ်ဖြာပြီး၊ ထိုပြဿနာငယ်များ၏ အဖြေများကို မှတ်သားထားကာ (caching) နောက်တစ်ကြိမ် ထပ်မံတွက်ချက်ရန်မလိုဘဲ ပြန်လည်အသုံးပြုသည့် နည်းစနစ်ဖြစ်သည်။ ၎င်းသည် naive recursive solutions များ၏ performance ကို အဆများစွာ တိုးတက်စေသည်။</p>
<p>DP တွင် အဓိက နည်းလမ်းနှစ်မျိုးရှိသည်။</p>
<ol>
<li><strong>Memoization (Top-Down):</strong> ပြဿနာကြီးမှ စတင်၍ recursive ခေါ်ဆိုပြီး၊ subproblem တစ်ခု၏ အဖြေကို ပထမဆုံးအကြိမ် တွက်ချက်ပြီးတိုင်း cache (e.g., map or array) ထဲတွင် မှတ်သားထားသည်။ နောက်တစ်ကြိမ် ထို subproblem ကို ထပ်မံတွေ့ရှိပါက တွက်ချက်မနေတော့ဘဲ cache မှ အဖြေကို ချက်ချင်းပြန်ယူသုံးသည်။</li>
<li><strong>Tabulation (Bottom-Up):</strong> အသေးငယ်ဆုံး subproblem မှ စတင်၍ အဖြေများကို တွက်ချက်ပြီး table (e.g., array) တစ်ခုတွင် သိမ်းဆည်းသည်။ ထို့နောက် ထိုအဖြေများကို အသုံးပြု၍ ပိုကြီးသော subproblem များကို တစ်ဆင့်ပြီးတစ်ဆင့် ဖြေရှင်းသွားပြီး နောက်ဆုံးတွင် မူလပြဿနာကြီး၏ အဖြေကို ရရှိသည်။</li>
</ol>
<h3 id="-fibonacci-sequence-memoization-">ဥပမာ ၁: Fibonacci Sequence (Memoization ဖြင့်)</h3>
<p>Fibonacci sequence <code>fib(n)</code> ကို တွက်ချက်ရာတွင် <code>fib(n-1)</code> နှင့် <code>fib(n-2)</code> ကို လိုအပ်သည်။ <code>fib(5)</code> ကို တွက်ရန် <code>fib(3)</code> ကို နှစ်ကြိမ် တွက်ချက်ရသည်ကို တွေ့ရမည်။ DP သည် ဤသို့ ထပ်ခါထပ်ခါ တွက်ချက်ခြင်းကို ရှောင်ရှားပေးသည်။</p>
<pre><code class="lang-go">// memo (map) ကို အသုံးပြု၍ တွက်ချက်ပြီးသား အဖြေများကို မှတ်သားထားမည်
func fibDP(n int, memo map[int]int) int {
    // 1. Cache ကို စစ်ဆေးခြင်း
    if val, ok := memo[n]; ok {
        return val // မှတ်သားထားသော အဖြေကို ပြန်ပေးသည်
    }
    // 2. Base case
    if n &lt;= 1 {
        return n
    }

    // 3. Recursive တွက်ချက်ခြင်း
    result := fibDP(n-1, memo) + fibDP(n-2, memo)

    // 4. အဖြေကို cache ထဲသို့ မှတ်သားခြင်း
    memo[n] = result
    return result
}</code></pre>
<h3 id="-climbing-stairs-tabulation-">ဥပမာ ၂: Climbing Stairs (Tabulation ဖြင့်)</h3>
<p><strong>ပြဿနာ:</strong> လှေကားထစ် N ထစ်ကို တက်ရန်အတွက် တစ်ကြိမ်လျှင် ၁ ထစ် သို့မဟုတ် ၂ ထစ် တက်နိုင်သည်။ နည်းလမ်းပေါင်း မည်မျှဖြင့် တက်နိုင်မည်နည်း။</p>
<p><strong>DP ဖြင့် ဖြေရှင်းခြင်း:</strong></p>
<ul>
<li><code>ways(n)</code> = လှေကားထစ် n ထစ်ကို တက်နိုင်သော နည်းလမ်းအရေအတွက်</li>
<li><code>ways(n) = ways(n-1) + ways(n-2)</code> (နောက်ဆုံးအဆင့်ကို ၁ ထစ်ဖြင့် တက်ခဲ့ခြင်း + နောက်ဆုံးအဆင့်ကို ၂ ထစ်ဖြင့် တက်ခဲ့ခြင်း)</li>
<li>Base cases: <code>ways(1) = 1</code>, <code>ways(2) = 2</code></li>
</ul>
<pre><code class="lang-go">func climbStairs(n int) int {
    if n &lt;= 2 {
        return n
    }
    // dp array (table) ကို တည်ဆောက်သည်
    dp := make([]int, n+1)
    dp[1] = 1
    dp[2] = 2

    // Bottom-up တွက်ချက်သည်
    for i := 3; i &lt;= n; i++ {
        dp[i] = dp[i-1] + dp[i-2]
    }

    return dp[n]
}</code></pre>
<h1 id="-context">အခန်း ၂၁: Context</h1>
<p>Go တွင် concurrent programming နှင့် network applications များ ရေးသားရာတွင် <code>context</code> package သည် အလွန်အရေးပါသော အခန်းကဏ္ဍမှ ပါဝင်ပါသည်။ <code>context.Context</code> သည် API boundaries များ (ဥပမာ- function calls, goroutines) တစ်လျှောက်တွင် cancellation signals, deadlines, နှင့် request-scoped values များကို သယ်ဆောင်ရန်အတွက် standard mechanism တစ်ခုဖြစ်သည်။</p>
<h2 id="-context-package-"><code>context</code> package ဆိုတာဘာလဲ။</h2>
<p><code>Context</code> သည် program တစ်ခု၏ execution path တစ်လျှောက်တွင် သက်ဆိုင်ရာ အချက်အလက်များကို လက်ဆင့်ကမ်း သယ်ဆောင်သွားသော &quot;context&quot; သို့မဟုတ် ပတ်ဝန်းကျင်တစ်ခု ဖြစ်သည်။ ၎င်း၏ အဓိက အသုံးဝင်မှုများမှာ-</p>
<ol>
<li><strong>Cancellation:</strong> Parent operation တစ်ခုက ၎င်းမှစတင်ခဲ့သော child operations (goroutines) များကို အချိန်မရွေး ရပ်တန့်စေနိုင်ခြင်း။</li>
<li><strong>Timeouts/Deadlines:</strong> Operation တစ်ခုကို အချိန်အကန့်အသတ်တစ်ခုအတွင်း ပြီးမြောက်ရန် သတ်မှတ်ပြီး၊ အချိန်ကျော်လွန်ပါက အလိုအလျောက် cancel လုပ်ခြင်း။</li>
<li><strong>Request-scoped Values:</strong> Request တစ်ခုနှင့်သာ သက်ဆိုင်သော data (e.g., request ID, user token) များကို function call chain တစ်လျှောက် လက်ဆင့်ကမ်း သယ်ဆောင်သွားခြင်း။</li>
</ol>
<blockquote>
<p>[!TIP]
<strong>Best Practice:</strong> Google ၏ အဆိုအရ <code>context.Context</code> ကို function ၏ ပထမဆုံး argument အဖြစ်သာ ထားရှိသင့်သည်။</p>
<pre><code class="lang-go">func DoSomething(ctx context.Context, arg string) error { ... }</code></pre>
<p>Struct များထဲတွင် Context ကို သိမ်းဆည်းခြင်းမပြုသင့်ပါ။</p>
</blockquote>
<p><code>Context</code> သည် immutable ဖြစ်သည်။ <code>context</code> အသစ်တစ်ခုကို ဖန်တီးလိုပါက ရှိပြီးသား parent context မှ child context အသစ်တစ်ခုကို ထုတ်ယူ (derive) ရသည်။</p>
<h2 id="context-">Context ဖန်တီးခြင်း</h2>
<p>Context empty ဖြစ်နေသောနေရာ (Root of the context tree) တွင် စတင်အသုံးပြုရန် function နှစ်ခုရှိသည်။</p>
<ol>
<li><p><code>context.Background()</code>:</p>
<ul>
<li>အသုံးအများဆုံးဖြစ်သည်။</li>
<li>Main functional, init function, tests, နှင့် incoming requests များ၏ top-level တွင် အသုံးပြုသည်။</li>
</ul>
</li>
<li><p><code>context.TODO()</code>:</p>
<ul>
<li>မည်သည့် context ကို သုံးရမည်မသိသေးချိန်၊ သို့မဟုတ် code ကို မပြီးပြတ်သေးချိန် (work in progress) တွင် ယာယီအသုံးပြုသည်။</li>
<li><code>nil</code> context ကို ဘယ်တော့မှ မသုံးသင့်ပါ။</li>
</ul>
</li>
</ol>
<h2 id="cancellation-">Cancellation (လုပ်ငန်းစဉ်များကို ရပ်တန့်စေခြင်း)</h2>
<p><code>context.WithCancel()</code> function သည် parent context မှ cancel function တစ်ခုပါဝင်သော child context အသစ်တစ်ခုကို ဖန်တီးပေးသည်။ ထို cancel function ကို ခေါ်လိုက်သည့်အခါ၊ ထို child context နှင့် ၎င်းမှ ဆင်းသက်လာသော context များအားလုံးသည် cancelled ဖြစ်သွားပြီး၊ ၎င်းတို့၏ <code>Done()</code> channel သည် close ဖြစ်သွားသည်။</p>
<p>Goroutines များသည် <code>ctx.Done()</code> channel ကို <code>select</code> statement ဖြင့် စောင့်ကြည့်နားထောင်ခြင်းဖြင့် cancellation signal ကို လက်ခံရရှိပြီး မိမိတို့၏ လုပ်ငန်းစဉ်များကို ဘေးကင်းစွာ ရပ်တန့်နိုင်သည်။</p>
<pre><code class="lang-mermaid">graph TD
    A[Parent Goroutine] -- &quot;creates&quot; --&gt; B[&quot;Context with Cancel&lt;br/&gt;(ctx, cancel)&quot;]
    A -- &quot;go longRunningOperation(ctx)&quot; --&gt; C[Child Goroutine]
    C -- &quot;listens on&quot; --&gt; D{&quot;ctx.Done()&quot;}

    subgraph &quot;After some time...&quot;
        A -- &quot;calls cancel()&quot; --&gt; E{Cancellation Signal}
    end

    E -- &quot;closes&quot; --&gt; D
    D -- &quot;unblocks&quot; --&gt; F[Child Goroutine stops its work]</code></pre>
<p><strong>ဥပမာ:</strong></p>
<pre><code class="lang-go">package main

import (
    &quot;context&quot;
    &quot;fmt&quot;
    &quot;time&quot;
)

func worker(ctx context.Context) {
    for {
        select {
        case &lt;-ctx.Done():
            // Cancellation signal ရရှိပါက goroutine မှ ထွက်ခွာမည်
            fmt.Println(&quot;Worker: cancellation signal received. Shutting down.&quot;)
            return
        default:
            // ပုံမှန်အလုပ်များကို ဆက်လက်လုပ်ဆောင်နေမည်
            fmt.Println(&quot;Worker: doing some work...&quot;)
            time.Sleep(500 * time.Millisecond)
        }
    }
}

func main() {
    // Background context မှ cancelable context အသစ်တစ်ခု ဖန်တီးသည်
    ctx, cancel := context.WithCancel(context.Background())

    go worker(ctx)

    // 2 seconds ကြာသောအခါ worker goroutine ကို cancel လုပ်မည်
    time.Sleep(2 * time.Second)
    fmt.Println(&quot;Main: sending cancellation signal.&quot;)
    cancel()

    // Worker goroutine မှ shutdown message ကို မြင်နိုင်ရန် ခေတ္တစောင့်ဆိုင်းသည်
    time.Sleep(1 * time.Second)
    fmt.Println(&quot;Main: finished.&quot;)
}</code></pre>
<h2 id="timeouts-deadlines">Timeouts နှင့် Deadlines</h2>
<p><code>context.WithTimeout()</code> နှင့် <code>context.WithDeadline()</code> functions များသည် အချိန်အကန့်အသတ်ဖြင့် context များကို ဖန်တီးရန် အသုံးပြုသည်။</p>
<ul>
<li><code>context.WithTimeout(parent, duration)</code>: လက်ရှိအချိန်မှစ၍ သတ်မှတ် <code>duration</code> ကြာပြီးနောက် အလိုအလျောက် cancel ဖြစ်မည့် context ကို ဖန်တီးသည်။</li>
<li><code>context.WithDeadline(parent, time)</code>: သတ်မှတ်ထားသော <code>time</code> အချိန်အတိအကျတွင် အလိုအလျောက် cancel ဖြစ်မည့် context ကို ဖန်တီးသည်။</li>
</ul>
<p>ဤသည်မှာ external network call များ သို့မဟုတ် database queries များကဲ့သို့ အချိန်ကြာမြင့်နိုင်သော operations များအတွက် အလွန်အသုံးဝင်သည်။</p>
<p><strong>ဥပမာ: HTTP Request Timeout</strong></p>
<pre><code class="lang-go">package main

import (
    &quot;context&quot;
    &quot;fmt&quot;
    &quot;net/http&quot;
    &quot;time&quot;
)

func main() {
    // 50 milliseconds timeout ဖြင့် context တစ်ခု ဖန်တီးသည်
    ctx, cancel := context.WithTimeout(context.Background(), 50*time.Millisecond)
    defer cancel() // context နှင့် သက်ဆိုင်သော resources များကို ရှင်းလင်းရန် အရေးကြီးသည်

    // HTTP request အသစ်တစ်ခု တည်ဆောက်သည်
    req, _ := http.NewRequestWithContext(ctx, &quot;GET&quot;, &quot;http://google.com&quot;, nil)

    // Request ကို ပေးပို့သည်
    fmt.Println(&quot;Sending request...&quot;)
    _, err := http.DefaultClient.Do(req)

    if err != nil {
        // Timeout ဖြစ်သွားပါက context deadline exceeded error ကို ရရှိမည်
        fmt.Println(&quot;Error:&quot;, err)
    } else {
        fmt.Println(&quot;Success!&quot;)
    }
}</code></pre>
<h2 id="request-scoped-values">Request-Scoped Values</h2>
<p><code>context.WithValue(parent, key, value)</code> function ကို အသုံးပြု၍ context ထဲတွင် key-value pair များကို သိမ်းဆည်းပြီး function call chain တစ်လျှောက် လက်ဆင့်ကမ်း သယ်ဆောင်သွားနိုင်သည်။</p>
<p><strong>အကောင်းဆုံး လိုက်နာရန် (Best Practice):</strong></p>
<ol>
<li><strong>Key Type:</strong> Key collision များ မဖြစ်စေရန်အတွက် key ကို <code>string</code> ကဲ့သို့သော built-in type များအစား ကိုယ်ပိုင် custom type (<code>type myKey string</code>) ဖြင့် သတ်မှတ်သင့်သည်။</li>
<li><strong>အသုံးဝင်ပုံ:</strong> <code>WithValue</code> ကို function တစ်ခုအတွက် optional parameters များ pass လုပ်ရန် <strong>မသုံးသင့်ပါ</strong>။ ၎င်းကို request-scoped data (e.g., request ID, user authentication info) ကဲ့သို့ process တစ်ခုလုံးနှင့် သက်ဆိုင်သော data များကို သယ်ဆောင်ရန်အတွက်သာ အသုံးပြုသင့်သည်။</li>
</ol>
<p><strong>ဥပမာ:</strong></p>
<pre><code class="lang-go">package main

import (
    &quot;context&quot;
    &quot;fmt&quot;
)

// Key အတွက် custom type တစ်ခု သတ်မှတ်ခြင်း
type key string

const requestIDKey key = &quot;requestID&quot;

func processRequest(ctx context.Context) {
    // Context မှ request ID ကို ထုတ်ယူခြင်း
    reqID, ok := ctx.Value(requestIDKey).(string)
    if !ok {
        reqID = &quot;unknown&quot;
    }
    fmt.Printf(&quot;Processing request with ID: %s\n&quot;, reqID)

    // အခြား function ကို context နှင့်အတူ ခေါ်ဆိုခြင်း
    logSomething(ctx, &quot;Starting step 1...&quot;)
}

func logSomething(ctx context.Context, message string) {
    reqID, _ := ctx.Value(requestIDKey).(string)
    fmt.Printf(&quot;[Log - %s] %s\n&quot;, reqID, message)
}

func main() {
    // Context ထဲသို့ request ID ကို ထည့်သွင်းသည်
    ctx := context.WithValue(context.Background(), requestIDKey, &quot;abc-123-xyz&quot;)

    processRequest(ctx)
}</code></pre>
<h1 id="-web-development-with-echo-framework">အခန်း ၂၂: Web Development with Echo Framework</h1>
<p>Go ၏ standard library ဖြစ်သော <code>net/http</code> သည် အလွန်ကောင်းမွန်သော်လည်း၊ ကြီးမားသော web application များ တည်ဆောက်ရာတွင် ပိုမိုလွယ်ကူမြန်ဆန်စေရန် Web Framework များကို အသုံးပြုလေ့ရှိသည်။ <strong>Echo</strong> သည် Go အတွက် လူကြိုက်အများဆုံး၊ စွမ်းဆောင်ရည်မြင့်မားပြီး (High Performance)၊ ရိုးရှင်းသော (Minimalist) web framework တစ်ခုဖြစ်သည်။</p>
<h2 id="echo-install-">Echo ကို Install ပြုလုပ်ခြင်း</h2>
<p>ပထမဦးစွာ Echo package ကို download လုပ်ရန်လိုအပ်သည်။</p>
<pre><code class="lang-sh">go get github.com/labstack/echo/v4</code></pre>
<h2 id="data-binding">Data Binding</h2>
<p>Echo သည် request payload (JSON, XML, Form) မှ data များကို Go struct သို့ပြောင်းလဲရန် <code>Bind</code> method ကို ထောက်ပံ့ပေးထားသည်။ ၎င်းသည် Content-Type header ကို ကြည့်ရှုပြီး အလိုအလျောက် mapping လုပ်ပေးသည်။</p>
<pre><code class="lang-go">type User struct {
    Name  string `json:&quot;name&quot; form:&quot;name&quot; query:&quot;name&quot;`
    Email string `json:&quot;email&quot; form:&quot;email&quot; query:&quot;email&quot;`
}

e.POST(&quot;/users&quot;, func(c echo.Context) error {
    u := new(User)
    if err := c.Bind(u); err != nil {
        return err
    }
    return c.JSON(http.StatusOK, u)
})</code></pre>
<h2 id="basic-echo-server">Basic Echo Server</h2>
<p>အောက်ပါ code သည် အရိုးရှင်းဆုံး Echo web server တစ်ခုဖြစ်သည်။</p>
<pre><code class="lang-go">package main

import (
    &quot;net/http&quot;
    &quot;github.com/labstack/echo/v4&quot;
)

func main() {
    // Echo instance တစ်ခု တည်ဆောက်ခြင်း
    e := echo.New()

    // Route တစ်ခု သတ်မှတ်ခြင်း
    e.GET(&quot;/&quot;, func(c echo.Context) error {
        return c.String(http.StatusOK, &quot;Hello, World!&quot;)
    })

    // Server ကို Port 8080 တွင် run ခြင်း
    e.Logger.Fatal(e.Start(&quot;:8080&quot;))
}</code></pre>
<ul>
<li><code>echo.New()</code>: Echo instance အသစ်တစ်ခုကို ဖန်တီးသည်။</li>
<li><code>e.GET(&quot;/&quot;, ...)</code>: HTTP GET request အတွက် route တစ်ခု သတ်မှတ်သည်။</li>
<li><code>c.String(...)</code>: String response ပြန်ပေးသည်။</li>
</ul>
<h2 id="echo-request-lifecycle">Echo Request Lifecycle</h2>
<p>Echo တွင် request တစ်ခု ဝင်ရောက်လာပုံနှင့် response ပြန်ထွက်သွားပုံကို နားလည်ရန် အရေးကြီးသည်။</p>
<pre><code class="lang-mermaid">graph LR
    Client((Client)) -- &quot;HTTP Request&quot; --&gt; Router[&quot;Router (Matches URL)&quot;]
    Router --&gt; Middleware[&quot;Middleware Chain&lt;br/&gt;(Logger, Recover, Auth)&quot;]
    Middleware --&gt; Handler[&quot;Handler Function&lt;br/&gt;(Business Logic)&quot;]
    Handler -- &quot;Returns Error/Data&quot; --&gt; Middleware
    Middleware -- &quot;HTTP Response&quot; --&gt; Client</code></pre>
<h2 id="routing">Routing</h2>
<p>Echo သည် routing ပိုင်းတွင် အလွန်စွမ်းဆောင်ရည်ကောင်းမွန်ပြီး ရေးသားရလွယ်ကူသည်။</p>
<h3 id="path-parameters">Path Parameters</h3>
<p>URL path ထဲရှိ value များကို ရယူရန် <code>:</code> ကို အသုံးပြုသည်။</p>
<pre><code class="lang-go">// e.g., GET /users/123
e.GET(&quot;/users/:id&quot;, func(c echo.Context) error {
    id := c.Param(&quot;id&quot;)
    return c.String(http.StatusOK, &quot;User ID: &quot; + id)
})</code></pre>
<h3 id="query-parameters">Query Parameters</h3>
<p>URL query string (e.g., <code>?name=John</code>) ကို ရယူရန် <code>QueryParam</code> ကို အသုံးပြုသည်။</p>
<pre><code class="lang-go">// e.g., GET /show?team=Arsenal&amp;member=Saka
e.GET(&quot;/show&quot;, func(c echo.Context) error {
    team := c.QueryParam(&quot;team&quot;)
    member := c.QueryParam(&quot;member&quot;)
    return c.String(http.StatusOK, &quot;Team: &quot; + team + &quot;, Member: &quot; + member)
})</code></pre>
<h2 id="context-responses">Context &amp; Responses</h2>
<p><code>echo.Context</code> သည် request နှင့် response ကို ကိုင်တွယ်ရန် အဓိက interface ဖြစ်သည်။</p>
<ul>
<li><p><strong>JSON Response:</strong></p>
<pre><code class="lang-go">type User struct {
    Name  string `json:&quot;name&quot;`
    Email string `json:&quot;email&quot;`
}

e.GET(&quot;/json&quot;, func(c echo.Context) error {
    u := &amp;User{
        Name:  &quot;Jon&quot;,
        Email: &quot;jon@labstack.com&quot;,
    }
    return c.JSON(http.StatusOK, u)
})</code></pre>
</li>
<li><p><strong>HTML Response:</strong></p>
<pre><code class="lang-go">e.GET(&quot;/html&quot;, func(c echo.Context) error {
    return c.HTML(http.StatusOK, &quot;&lt;strong&gt;Hello!&lt;/strong&gt;&quot;)
})</code></pre>
</li>
</ul>
<h2 id="middleware">Middleware</h2>
<p>Middleware ဆိုသည်မှာ request တစ်ခုကို handler function ဆီမရောက်ခင် သို့မဟုတ် response ပြန်မပေးခင် ကြားခံလုပ်ဆောင်ပေးသော function များဖြစ်သည်။ Echo တွင် built-in middleware များစွာပါဝင်သည်။</p>
<pre><code class="lang-go">import &quot;github.com/labstack/echo/v4/middleware&quot;

// ...

// Root level middleware
e.Use(middleware.Logger())  // Request တိုင်းကို log မှတ်ပေးသည်
e.Use(middleware.Recover()) // Panic ဖြစ်သွားလျှင် server မကျသွားအောင် ကာကွယ်ပေးသည်</code></pre>
<h3 id="custom-middleware-">Custom Middleware ရေးသားခြင်း</h3>
<p>မိမိကိုယ်ပိုင် middleware များကိုလည်း လွယ်ကူစွာ ရေးသားနိုင်သည်။</p>
<pre><code class="lang-go">func ServerHeader(next echo.HandlerFunc) echo.HandlerFunc {
    return func(c echo.Context) error {
        c.Response().Header().Set(&quot;X-Server&quot;, &quot;Echo/4.0&quot;)
        return next(c)
    }
}

func main() {
    e := echo.New()
    e.Use(ServerHeader)
    // ...
}</code></pre>
<h2 id="example-simple-rest-api">Example: Simple REST API</h2>
<p>အောက်ပါဥပမာသည် User များကို create လုပ်ခြင်းနှင့် get လုပ်ခြင်းအတွက် ရိုးရှင်းသော REST API တစ်ခုဖြစ်သည်။</p>
<pre><code class="lang-go">package main

import (
    &quot;net/http&quot;
    &quot;github.com/labstack/echo/v4&quot;
    &quot;github.com/labstack/echo/v4/middleware&quot;
)

type User struct {
    ID   string `json:&quot;id&quot;`
    Name string `json:&quot;name&quot;`
}

var users = []User{
    {ID: &quot;1&quot;, Name: &quot;Mg Mg&quot;},
    {ID: &quot;2&quot;, Name: &quot;Aung Aung&quot;},
}

func main() {
    e := echo.New()

    // Middleware
    e.Use(middleware.Logger())
    e.Use(middleware.Recover())

    // Routes
    e.GET(&quot;/users&quot;, getUsers)
    e.GET(&quot;/users/:id&quot;, getUser)
    e.POST(&quot;/users&quot;, createUser)

    e.Logger.Fatal(e.Start(&quot;:8080&quot;))
}

// Handler Functions

func getUsers(c echo.Context) error {
    return c.JSON(http.StatusOK, users)
}

func getUser(c echo.Context) error {
    id := c.Param(&quot;id&quot;)
    for _, u := range users {
        if u.ID == id {
            return c.JSON(http.StatusOK, u)
        }
    }
    return c.JSON(http.StatusNotFound, map[string]string{&quot;message&quot;: &quot;User not found&quot;})
}

func createUser(c echo.Context) error {
    u := new(User)
    if err := c.Bind(u); err != nil {
        return err
    }
    users = append(users, *u)
    return c.JSON(http.StatusCreated, u)
}</code></pre>
<p>ဤအခန်းတွင် Echo framework ၏ အခြေခံများကို မိတ်ဆက်ပေးခဲ့သည်။ Echo သည် အလွန်ကျယ်ပြန့်သော framework တစ်ခုဖြစ်ပြီး validation, JWT authentication, websocket စသည်တို့ကိုလည်း support ပေးပါသည်။ ပိုမိုလေ့လာရန် <a href="https://echo.labstack.com/">Echo Documentation</a> တွင် ဖတ်ရှုနိုင်ပါသည်။</p>
<h1 id="-next-steps-">အခန်း ၂၃: နောက်ထပ် လေ့လာစရာများ (Next Steps)</h1>
<p>ဤစာအုပ်တစ်လျှောက်တွင် သင်သည် Go programming language ၏ အခြေခံမှစ၍ concurrency, web development နှင့် data structures ကဲ့သို့သော အဆင့်မြင့် အကြောင်းအရာများအထိ လေ့လာခဲ့ပြီးဖြစ်ပါသည်။ သင်၏ Go programming ခရီးလမ်းသည် ဤနေရာတွင် မပြီးဆုံးသေးပါ။ ဤနောက်ဆုံးအခန်းသည် သင်၏ ကျွမ်းကျင်မှုကို ပိုမိုတိုးတက်စေရန်အတွက် နောက်ထပ် လေ့လာစရာများနှင့် အသုံးဝင်သော resources များကို လမ်းညွှန်ပေးသွားမည်ဖြစ်သည်။</p>
<h2 id="go-community-resources-">Go Community နှင့် Resources များ</h2>
<p>Programming language တစ်ခုကို သင်ယူရာတွင် community နှင့် ချိတ်ဆက်နေခြင်းသည် အလွန်အရေးကြီးပါသည်။ အကူအညီများ တောင်းခံရန်၊ အသိပညာများ မျှဝေရန်၊ နှင့် နောက်ဆုံးပေါ်သတင်းများကို သိရှိနိုင်ရန် အောက်ပါ resources များကို အသုံးပြုနိုင်ပါသည်။</p>
<ul>
<li><strong>The Go Website (go.dev):</strong> Go ၏ တရားဝင် website ဖြစ်ပြီး documentation, tutorials, နှင့် standard library reference များအတွက် အဓိကနေရာဖြစ်သည်။</li>
<li><strong>The Go Blog (go.dev/blog):</strong> Go team မှ တရားဝင်ရေးသားသော blog ဖြစ်ပြီး language updates, best practices, နှင့် case studies များကို ဖတ်ရှုနိုင်သည်။</li>
<li><strong>Effective Go (go.dev/doc/effective_go):</strong> Go language ကို idiomatic (Go ဆန်ဆန်) ဖြစ်အောင် မည်သို့ရေးသားရမည်ကို လမ်းညွှန်ထားသော မဖြစ်မနေ ဖတ်ရှုသင့်သည့် စာတမ်းဖြစ်သည်။</li>
<li><strong>Go Playground (go.dev/play):</strong> Go code များကို browser ထဲမှာပင် တိုက်ရိုက် run ကြည့်နိုင်သော online editor ဖြစ်သည်။ Code snippet များကို အလွယ်တကူ share ရန် အလွန်အသုံးဝင်သည်။</li>
<li><strong>Gophers Slack:</strong> ကမ္ဘာတစ်ဝှမ်းမှ Go developer များ စုဝေးရာ Slack workspace ဖြစ်သည်။ မေးခွန်းများမေးရန်နှင့် ဆွေးနွေးမှုများတွင် ပါဝင်ရန် အကောင်းဆုံးနေရာတစ်ခုဖြစ်သည်။</li>
<li><strong>Reddit (r/golang):</strong> Go နှင့်ပတ်သက်သော သတင်းများ၊ ဆွေးနွေးမှုများ၊ နှင့် project showcases များအတွက် တက်ကြွသော subreddit တစ်ခုဖြစ်သည်။</li>
<li><strong>Awesome Go (github.com/avelino/awesome-go):</strong> Go frameworks, libraries, နှင့် tools များ၏ အလွန်ကျယ်ပြန့်သော curated list တစ်ခုဖြစ်သည်။ Project အသစ်တစ်ခုအတွက် library ရှာဖွေလိုပါက ဤနေရာတွင် စတင်ကြည့်ရှုသင့်သည်။</li>
</ul>
<h2 id="-third-party-libraries-">အသုံးဝင်သော Third-party Libraries များ</h2>
<p>Standard library သည် အစွမ်းထက်သော်လည်း၊ third-party libraries များက development process ကို ပိုမိုမြန်ဆန်လွယ်ကူစေပါသည်။ အသုံးများသော libraries အချို့မှာ-</p>
<ul>
<li><strong>Web Frameworks/Routers:</strong><ul>
<li><code>gin-gonic/gin</code>: Performance အလွန်ကောင်းမွန်ပြီး features များစွာပါဝင်သော web framework တစ်ခု။</li>
<li><code>labstack/echo</code>: High-performance, extensible, minimalist web framework တစ်ခု။</li>
<li><code>gorilla/mux</code>: ကျွန်ုပ်တို့၏ project တွင် အသုံးပြုခဲ့သည့်အတိုင်း၊ အစွမ်းထက်သော HTTP router တစ်ခု။</li>
</ul>
</li>
<li><strong>ORM &amp; Database Tooling:</strong><ul>
<li><code>gorm</code>: Go အတွက် အသုံးအများဆုံး ORM (Object-Relational Mapping) library တစ်ခု။</li>
<li><code>sqlx</code>: Standard <code>database/sql</code> package ကို အခြေခံ၍ ပိုမိုအသုံးဝင်သော features များ ထပ်တိုးပေးထားသော extension တစ်ခု။</li>
</ul>
</li>
<li><strong>Logging:</strong><ul>
<li><code>zerolog</code>: High-performance JSON logger တစ်ခု။</li>
<li><code>zap</code>: Uber မှ ထုတ်လုပ်သော အလွန်မြန်ဆန်သည့် structured logging library တစ်ခု။</li>
</ul>
</li>
<li><strong>Configuration Management:</strong><ul>
<li><code>spf13/viper</code>: Application configuration များကို files, environment variables, remote K/V stores များမှ ဖတ်ရှုရန်အတွက် ပြည့်စုံသော solution တစ်ခု။</li>
</ul>
</li>
<li><strong>Testing:</strong><ul>
<li><code>stretchr/testify</code>: Standard <code>testing</code> package ကို assertions နှင့် mocking tools များဖြင့် ပိုမိုလွယ်ကူအောင် ကူညီပေးသော library တစ်ခု။</li>
</ul>
</li>
</ul>
<h2 id="-">ဆက်လက်လေ့လာရန် လမ်းညွှန်ချက်များ</h2>
<p>သင်၏ Go ကျွမ်းကျင်မှုကို နောက်တစ်ဆင့်သို့ တက်လှမ်းရန်အတွက် အောက်ပါတို့ကို ဆက်လက်လုပ်ဆောင်သင့်သည်။</p>
<ul>
<li><strong>Standard Tools များကို အသုံးပြုပါ:</strong><ul>
<li><code>go fmt</code>: Code များကို standard format အတိုင်း အလိုအလျောက် ပြင်ဆင်ပေးသည်။ Editor တိုင်းတွင် save လုပ်လျှင် run အောင် setup လုပ်ထားသင့်သည်။</li>
<li><code>go vet</code>: Code တွင် ဖြစ်နိုင်ခြေရှိသော အမှားများ (bugs) ကို static analysis ဖြင့် ရှာဖွေပေးသည်။</li>
</ul>
</li>
<li><strong>Project များ ပိုမိုတည်ဆောက်ပါ:</strong> သင်ယူခဲ့သော အသိပညာများကို လက်တွေ့အသုံးချရန် အကောင်းဆုံးနည်းလမ်းမှာ project များ တည်ဆောက်ခြင်းဖြစ်သည်။ ဥပမာ-<ul>
<li>Command-Line Interface (CLI) tool တစ်ခု။</li>
<li>Database ပါဝင်သော ပိုမိုရှုပ်ထွေးသည့် REST API တစ်ခု။</li>
<li>Website တစ်ခုမှ data များကို ဆွဲထုတ်သည့် Web Scraper တစ်ခု။</li>
<li>File များကို process လုပ်သည့် concurrent data processor တစ်ခု။</li>
</ul>
</li>
<li><strong>Open Source Projects များတွင် ပါဝင်ပါ:</strong> GitHub ပေါ်ရှိ သင်စိတ်ဝင်စားသော Go open-source project များတွင် bug fix များ၊ documentation improvements များ၊ သို့မဟုတ် feature အသစ်များ ပါဝင်ရေးသားခြင်းဖြင့် လက်တွေ့အတွေ့အကြုံများစွာ ရရှိနိုင်သည်။</li>
<li><strong>Concurrency Patterns များကို နက်နက်နဲနဲ လေ့လာပါ:</strong> <code>WaitGroup</code> နှင့် <code>channels</code> များအပြင်၊ worker pools, fan-in/fan-out, rate limiting ကဲ့သို့သော advanced concurrency patterns များကို လေ့လာပါ။</li>
<li><strong>Performance Tuning ကို လေ့လာပါ:</strong> Go ၏ built-in profiling tool ဖြစ်သော <code>pprof</code> ကို အသုံးပြု၍ သင်၏ application ၏ performance bottlenecks များကို ရှာဖွေပြီး optimize လုပ်နည်းကို လေ့လာပါ။</li>
<li><strong>System Design ကို လေ့လာပါ:</strong> Go ကို microservices, distributed systems, နှင့် cloud-native applications များ တည်ဆောက်ရာတွင် မည်သို့အသုံးပြုသည်ကို လေ့လာခြင်းဖြင့် ဗိသုကာပိုင်းဆိုင်ရာ အမြင်ကို ကျယ်ပြန့်စေသည်။</li>
</ul>
<h2 id="-">နိဂုံး</h2>
<p>Go programming language သည် ရိုးရှင်းမှု၊ စွမ်းဆောင်ရည်၊ နှင့် concurrency တို့ကြောင့် ခေတ်မီ software development တွင် နေရာတစ်ခု အခိုင်အမာ ရယူထားပါသည်။ ဤစာအုပ်သည် သင်၏ Go ခရီးလမ်းအတွက် ခိုင်မာသော အခြေခံအုတ်မြစ်တစ်ခု ချပေးနိုင်ခဲ့မည်ဟု မျှော်လင့်ပါသည်။ စဉ်ဆက်မပြတ် လေ့လာခြင်း၊ လက်တွေ့တည်ဆောက်ခြင်း၊ နှင့် community တွင် ပါဝင်ခြင်းတို့ဖြင့် သင်သည် ထူးချွန်သော Go developer တစ်ယောက် ဖြစ်လာနိုင်မည်မှာ မလွဲဧကန်ပင်။</p>
<p>Happy coding!</p>

    </article>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"></script>
    <!-- and it's easy to individually load additional languages -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/languages/go.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@11.12.0/dist/mermaid.min.js"></script>
    <script>
        // Convert all language-mermaid code blocks to mermaid class
        document.querySelectorAll('code.lang-mermaid').forEach(code => {
            const pre = code.parentElement;
            pre.classList.add('mermaid');
            // Remove the code wrapper if needed
            pre.innerHTML = code.textContent;
        });
    </script>
    <script>hljs.highlightAll();</script>
  </body>
</html>

